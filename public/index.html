<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Origami Actuators</title>
		<!-- <link rel="stylesheet" href="css/style.css" type="text/css" /> -->
		<style>
			body { margin: 0; }
		</style>
	</head>
	
	<body>
		<!-- <script src="../node_modules/three/build/three.min.js"></script> -->
		<script type="importmap">
			{
				"imports": {
					"three": "../node_modules/three/build/three.module.js",
					"three/addons/": "../node_modules/three/examples/jsm/",
					"cannon-es": "../node_modules/cannon-es/dist/cannon-es.js"
				}
			}
		</script>
		
        <script type="module">
			import * as THREE from 'three'
			import * as CANNON from 'cannon-es'
			import {GUI} from 'three/addons/libs/lil-gui.module.min.js'
			import {OrbitControls} from 'three/addons/controls/OrbitControls.js'
			
			/**
			 * Todo List:
			 * Bending tube simulation (LJX)
			 * Deflate and inflate simulation not stop (LJX)
			 * Reset folding ratio to 0.75
			*/
			
			// Three.js variables for render
			let renderer, camera, scene
			let controls, gui
			
			// Cannon.js variables for physical simulation
			let world
			let constraints = []
			let useGravity = false
			
			// Set hinge motor velocity that determines speed and direction
			const initialHingeVelocity = 0
			const foldingVelocity = Math.PI / 2
			const foldingDuration = 1600
			const unfoldingVelocity = -Math.PI / 4
			const unFoldingDuration = 3000
			const disSquMin = 380
			const disSquMax = 720
			
			// Keep in sync the bodies with the visuals, they always have the same length
			let bodies = []
			let visuals = []
			
			// User interaction variables
			let tubeList = []
			let connectorBodies = []
			
			initThree()
			initCannon()
			
			connectTube()
			animate()
			
			deflateTube()
			// inflateTube()
			
			initGUI()
			
			function connectTube() {
				/**
				 * Initialize a default connector in the physical world and visualize it in the scene
				 * Get parameters from the user interface
				 * Let users manipulate tubes in the scene by selecting the connector and pre-defined angles
				*/
				const defaultConnector = initDefaultConnector()
				connectorBodies.push( defaultConnector )
				bodyToMesh( defaultConnector ).forEach( (mesh) => scene.add(mesh) )
				
				var connectorIndex = 0
				var angleIndex = 0
				var tube1 = addMiuraTube( connectorIndex, angleIndex )
				tubeList.push( tube1 )
				
				var connectorIndex = 0
				var angleIndex = 1
				var tube2 = addMiuraTube( connectorIndex, angleIndex )
				tubeList.push( tube2 )
				
				var connectorIndex = 0
				var angleIndex = 2
				var tube3 = addMiuraTube( connectorIndex, angleIndex )
				tubeList.push( tube3 )
				
				var connectorIndex = 0
				var angleIndex = 3
				var tube4 = addMiuraTube( connectorIndex, angleIndex )
				tubeList.push( tube4 )
			}
			
			function addMiuraTube( connectorIndex, angleIndex ) {
				/**
				 * Initiate a new physical tube with customized position and quaternion
				 * Treat a new miura-ori tube as a three.js group and render
				 * Automatically add connector bodies to the tube
				 * https://github.com/schteppe/cannon.js/issues/71
				*/
				
				// Calculate position and quaternion according to the connectorIndex and angleIndex
				const quaternion = new CANNON.Quaternion()
				if ( angleIndex == 0 ) {
					// Pre-defined angles
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), 0 )
				} else if ( angleIndex == 1 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), Math.PI/2 )
				} else if ( angleIndex == 2 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), Math.PI )
				} else if ( angleIndex == 3 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), Math.PI/2*3 )
				}
				
				const intervalDistance = 12.954878  // half width of the Miura-ori tube unit
				const sphereRadius = 15.0  // Connector bounding sphere radius
				const unitVec = new CANNON.Vec3( sphereRadius + intervalDistance, 0, 0 )
				quaternion.vmult( unitVec, unitVec )
				const position = new CANNON.Vec3().copy(unitVec)
				
				// Render tube physical bodies to the view based on customized position and quaternion
				const tube = new THREE.Group()
				const hingeBodies = initDefaultMiuraTube( position, quaternion )
				hingeBodies.forEach( (body, i) => {
					const meshes = bodyToMesh( body )
					meshes.forEach( (mesh) => { tube.add( mesh ) } )
				})
				scene.add(tube)
				
				// Automatically add new connector body to the scene
				const newConnector = attachConnector( connectorIndex, hingeBodies, unitVec )
				connectorBodies.push( newConnector )
				bodyToMesh( newConnector ).forEach( (mesh) => scene.add(mesh) )
			}
			
			function initDefaultConnector() {
				/**
				 * Initialize a default connector in the physical world
				*/
				const sphereRadius = 15
				const sphereShape = new CANNON.Sphere(sphereRadius)
				
				const defaultConnector = new CANNON.Body({
					mass: 0,
					type: CANNON.Body.DYNAMIC,
					shape: sphereShape,
					position: new CANNON.Vec3(0,0,0)
				})

				// No collision needed
				defaultConnector.collisionFilterGroup = 0
				defaultConnector.collisionFilterMask = 0
				world.addBody(defaultConnector)
				
				return defaultConnector
			}
			
			function attachConnector( connectorIndex, hingeBodies, unitVec ) {
				/**
				 * Add lock constraints between the selected connector and hinge bodies
				 * Attach a new connector to the end of the tube
				*/
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[0] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[2] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[4] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[6] ))

				// Pre-defined tube bounding box dimensions: length => 155.458538, width => 37.288780, height => 17.527490
				const bBoxLength = 155.458538
				const bBoxWidth = 37.288780
				const bBoxHeight = 17.527490
				
				// Attach a new connector
				const sphereRadius = 15
				const sphereShape = new CANNON.Sphere(sphereRadius)
				const boxShape = new CANNON.Box(new CANNON.Vec3(10,10,10))
				
				const connectorPos = unitVec.unit()
				const distance = bBoxLength + sphereRadius * 2
				connectorPos.scale(distance, connectorPos)
				
				const newConnector = new CANNON.Body({
					mass: 0.1,
					type: CANNON.Body.DYNAMIC,
					shape: sphereShape,
					position: connectorPos
				})
				newConnector.collisionFilterGroup = 0
				newConnector.collisionFilterMask = 0
				world.addBody(newConnector)
				
				world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-1] ))
				world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-3] ))
				world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-5] ))
				world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-7] ))

				return newConnector
			}
			
			function initDefaultMiuraTube( position, quaternion ) {
				/**
				 * Store face coordinates from the Grasshopper file with 0.65 folding ratio
				 * Store vertices and indices for the body and geometry of the miura-ori tube
				 * Initiate the physical miura-ori tube with Trimesh shape
				 * Specify hinge constraints with axis and pivot point
				*/				
				const faceVertices_1 = new Float32Array([
					0, 0, 0,
					0, 12.173610, 8.763745,
					-12.95488, -0.768048, 8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_2 = new Float32Array([
					0, 0, 0,
					12.95488, -12.941658, 0,
					12.954878, -0.768048, 8.763745,
					0, 12.173610, 8.763745
				])
				const faceVertices_3 = new Float32Array([
					0, 12.173610, 8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, 8.763745
				])
				const faceVertices_4 = new Float32Array([
					0, 12.173610, 8.763745,
					12.954878, -0.768048, 8.763745,
					12.954878, 11.405561, 0,
					0, 24.347219, 0
				])
				const faceVertices_5 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					-12.954878, -0.768048, -8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_6 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					12.954878, -0.768048, -8.763745,
					12.954878, -12.941658, 0
				])
				const faceVertices_7 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, -8.763745
				])
				const faceVertices_8 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					12.954878, 11.405561, 0,
					12.954878, -0.768048, -8.763745
				])
				
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				// Number of faces in a miura-ori unit
				const unitNumber = 6	// a miura-ori tube has 6 units
				const unitFacesNum = 8  // a unit has 8 quadrilaterals
				let hingeBodiesArray = new Array( unitNumber * unitFacesNum )
				const mass = 1
				
				// Set the quaternion of the intervalVec
				const intervalDistance = 12.954878 * 2
				const intervalVec = new CANNON.Vec3( intervalDistance, 0, 0 )
				const intervalQuat = new CANNON.Quaternion().copy( quaternion )	// Rotate the intervalVec
				intervalQuat.vmult( intervalVec, intervalVec )
				
				// Whether to add hinge constraints (for test)
				const useHingeConstraints = true
				
				// Initiatize hinge bodies with shape
				for ( let i = 0; i < unitNumber; i++ ) {
                    hingeBodiesArray[ i*unitFacesNum ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum ] )
                    
					hingeBodiesArray[ i*unitFacesNum+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+1 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+2 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+3 ] )

					hingeBodiesArray[ i*unitFacesNum+4 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_5, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+4 ] )
					
					hingeBodiesArray[ i*unitFacesNum+5 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_6, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+5 ] )

					hingeBodiesArray[ i*unitFacesNum+6 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_7, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+6 ] )
					
					hingeBodiesArray[ i*unitFacesNum+7 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_8, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+7 ] )
                }
				
				// Specify a list of hinge constraints
				if (useHingeConstraints) {
					for ( let i = 0; i < unitNumber; i++ ) {
						const axis1 = new CANNON.Vec3( 0, 0.811574, 0.58425 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+1 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis1,	
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis1,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis2 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+2 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis2,
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis2,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis3 = new CANNON.Vec3( 0.707468, -0.706746, 0 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis3,
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis3,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis4 = new CANNON.Vec3( 0, -0.811574, 0.58425 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis4,	
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis4,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis5 = new CANNON.Vec3( 0, -0.811574, 0.58425 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis5,	
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis5,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis6 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis6,
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis6,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis7 = new CANNON.Vec3( -0.707468, 0.706746, 0 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis7,
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis7,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis8 = new CANNON.Vec3( 0, 0.811574, 0.58425 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+6 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis8,	
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis8,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis9 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+4 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis9,
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis9,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis10 = new CANNON.Vec3( 0.707468, -0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis10,
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis10,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis11 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisA: axis11,
								pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisB: axis11,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis12 = new CANNON.Vec3( -0.707468, 0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisA: axis12,
								pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisB: axis12,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						// Specify hinge constraints to connect multiple units
						if ( i < unitNumber -1 ) {
							const axis13 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // mountain hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ (i+1)*unitFacesNum ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
									axisA: axis13,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
									axisB: axis13,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis14 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // vally hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ (i+1)*unitFacesNum+2 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
									axisA: axis14,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
									axisB: axis14,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis15 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // mountain hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ (i+1)*unitFacesNum+4 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
									axisA: axis15,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
									axisB: axis15,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis16 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // vally hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+7], hingeBodiesArray[ (i+1)*unitFacesNum+6 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
									axisA: axis16,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
									axisB: axis16,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
						}
					}
				}

				const stiffness = 1e10
				const relaxation = 0.5
				const timeStep = 1/60
				// add the constraints to the world and enable hinge motor
				constraints.forEach( function( constraint ) {
					constraint.equations.forEach(function( equation ) {
						// set greater stiffness on the hinge
						equation.setSpookParams( stiffness, relaxation, timeStep )
					})
					
					constraint.enableMotor()
					constraint.setMotorSpeed( initialHingeVelocity )
					world.addConstraint( constraint )
				})

				return hingeBodiesArray
			}
			
			function initFlatMiuraTube() {
				/**
				 * Note that this function folds the tube from a flat surface
				 * Store vertices and indices for the geometry of miura-ori tube
				 * Initiate the physical miura-ori tube with Trimesh shape
				 * Specify hinge constraints with axis and pivot point
				*/
				const faceVertices_1 = new Float32Array([
					0, -15, 0,
					0, 0, 0, 
					-15.0, -10.503123, 0,
					-15.0, -25.503113, 0
				])
				const faceVertices_2 = new Float32Array([
					0, -15, 0,	
					15.0, -25.503113, 0,
					15.0, -10.503123, 0,
					0, 0, 0
				])
				const faceVertices_3 = new Float32Array([
					0, 0, 0,
					0, 15.0, 0,
					-15.0, 4.496877, 0,
					-15.0, -10.503123, 0
				])
				const faceVertices_4 = new Float32Array([
					0, 0, 0,
					15.0, -10.503123, 0,
					15.0, 4.496877, 0,
					0, 15.0, 0
				])
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				const mass = 10
				const intervalDistance = 15.0 * 2
				
				// Define hinge bodies
				for (let i = 0; i < unitNumber; i++) {
                    hingeBodiesArray[ i*4 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4 ] )
                    
					hingeBodiesArray[ i*4+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+1 ] )
                    
					hingeBodiesArray[ i*4+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+2 ] )
                    
					hingeBodiesArray[ i*4+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+3 ] )
                }
				
				// Specify a list of constraints
				for (let i = 0; i < unitNumber; i++) {
					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4 ], hingeBodiesArray[ i*4+1 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0, 1, 0), // vally hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0, 1, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4 ], hingeBodiesArray[ i*4+2 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0.819252, 0.573576, 0), // mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0.819252, 0.573576, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4+1 ], hingeBodiesArray[ i*4+3 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0.819252, -0.573576, 0),	// mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0.819252, -0.573576, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4+2 ], hingeBodiesArray[ i*4+3 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0,-1,0),	// mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0,-1,0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)
					
					if ( i < unitNumber -1 ) {
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*4+1 ], hingeBodiesArray[ (i+1)*4 ], {
								pivotA: new CANNON.Vec3(15, 0, 0),
								axisA: new CANNON.Vec3(0, -1, 0), // mountain hinge
								pivotB: new CANNON.Vec3(-15, 0, 0),
								axisB: new CANNON.Vec3(0, -1, 0),
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*4+3 ], hingeBodiesArray[ (i+1)*4+2 ], {
								pivotA: new CANNON.Vec3(15, 0, 0),
								axisA: new CANNON.Vec3(0, 1, 0), // vally hinge 
								pivotB: new CANNON.Vec3(-15, 0, 0),
								axisB: new CANNON.Vec3(0, 1, 0),
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
					}
				}
				
				const stiffness = 1e10
				const relaxation = 4
				const timeStep = 1/60
				// add the constraints to the world and enable hinge motor
				constraints.forEach( function( constraint ) {
					constraint.equations.forEach(function( equation ) {
						// set greater stiffness on the hinge
						equation.setSpookParams( stiffness, relaxation, timeStep )
					})
					
					constraint.enableMotor()
					constraint.setMotorSpeed( initialHingeVelocity )
					world.addConstraint( constraint )
				})
			}
			
			function initCannon() {
				world = new CANNON.World()
				world.solver.iterations = 50
				world.quatNormalizeFast = true
				
				// Set the gravity vector
				if (useGravity == true) {
					world.gravity.set(0, -9.82, 0)
				}
				
				// Create a static ground
				const groundBody = new CANNON.Body({
					type: CANNON.Body.Static,
					shape: new CANNON.Plane(),
					material: new CANNON.Material('ground')
				})
				
				// Visualization of the plane geometry is defined in initThree()
				groundBody.quaternion.setFromEuler( -Math.PI / 2, 0, 0 )
				groundBody.position.set( 0, -60, 0 )
				world.addBody(groundBody)
			}
			
			function bodyToMesh( body ) {
				/**
				 * Convert cannon bodies to three.js meshes directly
				*/
				if ( !(body instanceof CANNON.Body) ) {
					throw new Error('The argument passed to bodyToMesh() is not a body')
				}

				// Materials
				const basicMaterial = new THREE.MeshBasicMaterial( {color: 0x44aa88, side: THREE.DoubleSide, wireframe: false} )
				const phongMaterial = new THREE.MeshPhongMaterial( {color: 0x44aa88, side: THREE.DoubleSide, wireframe: false} )
				const normalMaterial = new THREE.MeshNormalMaterial( {side: THREE.DoubleSide, wireframe: false} )
				const material = normalMaterial
				// const colors = new Float32Array()
				
				// Get the mesh of body
				const meshes = body.shapes.map( (shape) => {
					switch (shape.type) {
						// check the shape type
						case CANNON.Shape.types.TRIMESH: {
							const verticeNum = shape.indices.length * 3
							const v0 = new CANNON.Vec3()
							const v1 = new CANNON.Vec3()
							const v2 = new CANNON.Vec3()
							
							const geometry = new THREE.BufferGeometry()
							const vertices = new Float32Array( verticeNum )
							const indices = new Uint16Array( shape.indices.length )
							let posNdx = 0
							
							for ( let i = 0; i < shape.indices.length / 3; i++ ) {
								shape.getTriangleVertices( i, v0, v1, v2 )
								
								const positions = [v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z]
								posNdx = posNdx + i * 3 * 3
								vertices.set( positions, posNdx )
								indices.set( [i*3, i*3+1, i*3+2], i * 3 )
							}
							// console.log(vertices)
							// console.log(indices)
							geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3) )
							geometry.setIndex( new THREE.BufferAttribute(indices, 1) )
							
							geometry.computeBoundingSphere()
							geometry.computeVertexNormals()
							
							return new THREE.Mesh( geometry, material )
						}
						
						case CANNON.Shape.types.SPHERE: {
							const geometry = new THREE.SphereGeometry( shape.radius )
							return new THREE.Mesh( geometry, material )
						}
						
						case CANNON.Shape.types.BOX: {
							const geometry = new THREE.BoxGeometry( shape.halfExtents.x * 2, shape.halfExtents.y * 2, shape.halfExtents.z * 2 )
							return new THREE.Mesh( geometry, material )
						}
					}
				})
				
				// Multiple shapes in one body (compound body)
				meshes.forEach( (mesh, i) => {
					// console.log(mesh)
					mesh.position.copy( body.shapeOffsets[i] )
					mesh.quaternion.copy( body.shapeOrientations[i] )
					// enable shadows on every object
					mesh.receiveShadow = true
    				mesh.castShadow = true
					
					bodies.push(body)
					visuals.push(mesh)
				})
				return meshes
			}
			
			function initThree() {
				THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 )
				
				// Renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } )
				renderer.setPixelRatio( window.devicePixelRatio )
				renderer.setSize( window.innerWidth, window.innerHeight )
				renderer.outputEncoding = THREE.sRGBEncoding
				document.body.appendChild( renderer.domElement )
				renderer.shadowMap.enabled = true
    			renderer.shadowMap.type = THREE.PCFSoftShadowMap
				
				renderer.shadowMap.enabled = true
        		renderer.shadowMap.type = THREE.PCFSoftShadowMap
				
				// Camera
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )
				camera.position.set( 0, 30, 300 )

				// Scene
				scene = new THREE.Scene()
				scene.background = new THREE.Color( 'rgb(240, 240, 240)' )
				
				// Lights
				scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.1 ) )
				const directionalLight = new THREE.DirectionalLight( 0xFFFFFF, 2 )
				directionalLight.position.set( -30, 40, 30 )
				directionalLight.target.position.set( 0, 0, 0 )
				scene.add( directionalLight )
				
				// Floor
				const floorGeometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 )
				floorGeometry.rotateX( -Math.PI / 2 )
				const floorMaterial = new THREE.MeshLambertMaterial( { color: 0x787878 } )
				const floor = new THREE.Mesh( floorGeometry, floorMaterial )
				floor.position.set( 0, -60, 0 )
				floor.receiveShadow = true
				scene.add(floor)
				
				// Orbit controls
				controls = new OrbitControls( camera, renderer.domElement )
				window.addEventListener( 'resize', onWindowResize )
				controls.rotateSpeed = 0.8
				controls.zoomSpeed = 0.2
				controls.enableDamping = true
				controls.enablePan = true
				controls.dampingFactor = 0.2
				controls.minDistance = 10
				controls.maxDistance = 500
			}
			
			function animate() {
				requestAnimationFrame( animate )
				
				// Step the physical simulation forward
				world.fixedStep()
				
				// update the position and orientation of the mesh to match the CannonBody
				for ( let i = 0; i < bodies.length; i++ ) {
					const body = bodies[i]
					const visual = visuals[i]
					visual.position.copy( bodies[i].position )
        			visual.quaternion.copy( bodies[i].quaternion )
				}
				
				// Stop hinge bodies folding through each other while deflation
				stopFacesFoldThrough()
				
				// Prevent the tube from becoming a flat surface while inflation
				stopInflation()
				
				// render three.js objects
				controls.update()
				renderer.render( scene, camera )
			}
			
			function deflateTube() {
				const velocity = foldingVelocity
				constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				
				// setTimeout(() => {
				// 	const velocity = 0
				// 	constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				// }, foldingDuration)
			}
			
			function stopFacesFoldThrough() {
				// Stop hinge bodies folding through each other by setting minimum distance while deflation
				if ( bodies[1].position.distanceSquared(bodies[9].position) <= disSquMin ) {
					const velocity = Math.PI / 1000
					console.log("stopFacesFoldThrough")
					console.log(velocity)
					constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				}
			}
			
			function inflateTube() {
				const velocity = unfoldingVelocity
				constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				
				// setTimeout(() => {
				// 	const velocity = 0
				// 	constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				// }, unFoldingDuration)
			}
			
			function stopInflation() {
				// Prevent the tube from becoming a flat surface while inflation
				if ( bodies[1].position.distanceSquared(bodies[9].position) >= disSquMax ) {
					const velocity = Math.PI / 1000
					console.log("stopInflation")
					console.log(velocity)
					constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				}
			}
			
			function onWindowResize() {
				const width = window.innerWidth
				const height = window.innerHeight
				camera.aspect = width / height
				camera.updateProjectionMatrix()
				renderer.setSize( width, height )
			}

			function initGUI() {
				/**
				 * user interface & design workflow
				*/
				let data = {
					x: 1
				}
				const gui = new GUI
				gui.add(data, "x", -5, -1, 0.01).onChange(() => {
					// geometry.attributes.position.array[3] = data.x
					// geometry.attributes.position.needsUpdate = true
				})
				gui.open();
			}
			
			// Mouse interactions
			window.addEventListener( 'pointdown', (event) => {
				// Fired when a pointer becomes active buttons state
			})

		</script>
	</body>
</html>