
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Origami Actuators</title>
		<!-- <link rel="stylesheet" href="css/style.css" type="text/css" /> -->
		<style>
			body { margin: 0; }
			.lil-gui {
				--font-size: 16px;
				--input-font-size: 16px;
				--widget-height: 35px;
				--width: 400px;
			}
		</style>
	</head>
	
	<body>
		<!-- <script src="../node_modules/three/build/three.min.js"></script> -->
		<script type="importmap">
			{
				"imports": {
					"three": "../node_modules/three/build/three.module.js",
					"three/addons/": "../node_modules/three/examples/jsm/",
					"cannon-es": "../node_modules/cannon-es/dist/cannon-es.js"
				}
			}
		</script>
		
        <script type="module">
			import * as THREE from 'three'
			import * as CANNON from 'cannon-es'
			import {GUI} from 'three/addons/libs/lil-gui.module.min.js'
			import {OrbitControls} from 'three/addons/controls/OrbitControls.js'
			
			/**
			 * Todo List:
			 * Reset folding ratio to 0.75 (CZT)
			 * Actuators belong to the same group will be displayed with same color (JX)
			*/
			
			// Three.js variables for render
			let renderer, camera, scene
			let controls
			
			// Cannon.js variables for physical simulation
			let world
			let useGravity = true
			
			// Set hinge motor velocity that determines speed and direction
			const initialHingeVelocity = 0
			const foldingVelocity = Math.PI / 2.5
			const foldingDuration = 1600
			const unfoldingVelocity = - Math.PI / 4
			const unFoldingDuration = 3000
			const disSquMin = 180
			const disSquMax = 720
			
			// Keep in sync the bodies with the visuals, they always have the same length
			let bodies = []
			let visuals = []
			
			// User interaction variables
			let tubeVisualList = []
			let tubeBodiesList = []
			let deflationTubes = []
			let inflationtubes = []
			let connectorMeshes = []
			let connectorBodies = []

			let airchannel = [] //加入空气分组
			let color = [] //每个分组颜色
			airchannel.push("Airchannel 1")
			airchannel.push("Airchannel 2")
			color.push(color16())
			color.push(color16())
			console.log(color)
			const gui = new GUI()
			var step1 = gui.addFolder( 'Step 1: Create a Shape' )
			var step2 = gui.addFolder( 'Step 2: Group Actuators' )

			
			var controltype = {
				'type': "none",
			}
			
			const step1obj = {
				'Type of actuator': 'linear actuator',
				'Add a new actuator': function() { console.log('addtube') },
				'Remove an actuator': function() { console.log('removetube') },
				'Load mesh': function() { console.log('load mesh and convert edges to actuators') }
			}
			
			const step4obj = {
				'Generate control code': function() {}
			}
			const step3obj = {
				'Choose an air channel': 'Air channel 1',
				'Actuation method': 'Deflation',
				'Start time (s)': 0.5,
				'End time (s)': 3.0,
				'Add to sequence motion': function() {},
				'Preview motion': true,
				'Add loop control': true,
				'finish': function() {//按钮生成下一步界面
					var step4 = gui.addFolder( 'Step 4: Assemble & Generate Control Code' )
					step4.add( step4obj, 'Generate control code' )
					step4.open()
				}
			}
			
			var step2obj = {
				// 'Select actuators to create an air channel': function() {selectActuators()},
				'Airchannel 1': function() {
					controltype.type = "Airchannel 1"
				},
				'Airchannel 2': function() {
					controltype.type = "Airchannel 2"
				},
				//按钮添加分组
				'finish' : function(){//完成分组按钮此时生成第三步界面
					controltype.type = "finish"
					var step3 = gui.addFolder( 'Step 3: Add Actuation & Preview Motion' )
					step3.add( step3obj, 'Choose an air channel', airchannel )
					step3.add( step3obj, 'Actuation method', ['Deflation', 'Inflation'] )
					step3.add( step3obj, 'Start time (s)', 0, 1, 0.1 )
					step3.add( step3obj, 'End time (s)', 1, 5, 0.1 )
					step3.add( step3obj, 'Add to sequence motion' )
					step3.add( step3obj, 'Preview motion' )
					step3.add( step3obj, 'Add loop control' )
					step3.add( step3obj, 'finish')
					step3.open()
				},
				'+' : function(){//空气分组
					var num = -1
					for (var i in step2obj){
						num++
					}
					var str = num + ''
					console.log(str)
					step2obj["Airchannel "+ str] = function(){
						controltype.type = "Airchannel "+ str
					}
					// step2obj.prototype.name = 'airchannel3'
					step2.add( step2obj, "Airchannel "+ str )
					airchannel.push("Airchannel "+ str)
					color.push(color16())
					console.log(airchannel)	
				}
			}
			



			
			let INTERSECTED = 0
			
			initThree()
			initCannon()
			
			connectTube()
			animate()
			
			// deflateTube( deflationTubes )
			// inflateTube( inflationConstraints )
			
			initGUI()

			function inGroupmode(mode){//判断是否在分组模式
				var flag = 0
				for (var i in step2obj){
						if(i==mode){
							flag = 1
						}
					}
				return flag
			}

			function color16(){//十六进制颜色随机
				var color =Math.floor(Math.random()*16777215)
				return color;
			}

			function initGUI() {
				/**
				 * User interface & design workflow
				*/				
				step1.add( step1obj, 'Type of actuator', ['linear actuator', 'bending actuator'] )
				step1.add( step1obj, 'Add a new actuator' )
				step1.add( step1obj, 'Remove an actuator' )
				step1.add( step1obj, 'Load mesh', 'Load mesh' )
				step1.open()
				
				step2.add( step2obj, '+' )
				step2.add( step2obj, 'finish' )
				step2.add( step2obj, 'Airchannel 1' )
				step2.add( step2obj, 'Airchannel 2' )
				step2.open()
				
			}
			
			// Mouse interactions
			window.addEventListener( 'pointerdown', (event) => {
				/**
				 * Fired when a pointer becomes active state
				 * Cast a ray from where the mouse is pointing to select a connector
				 * Get 3D point from the client x y coordinates
				*/
				const mouse = new THREE.Vector2()
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1
        		mouse.y = -(( event.clientY / window.innerHeight ) * 2 - 1)
				
				// Get the picking ray from the point
				const raycaster = new THREE.Raycaster()
				raycaster.setFromCamera( mouse, camera )
				
				// Loop the data lists to get which object is selected
				const connectorNum = connectorMeshes.length
				const tubeNum = tubeVisualList.length
				
				// if ( type.type == 'add' ) {			
				// 	for ( let i = 0; i<connectorNum; i++ ) {
				// 		const hits = raycaster.intersectObject( connectorMeshes[i] )
				// 		// Get the closest hit object
				// 		if (hits.length > 0) {
				// 			// const object = hits[0].object
				// 			if(testObj.tube== "bending" ) {
				// 				var tubeType = 1
				// 				var connectorIndex = i
				// 				var angleIndex = testObj.angle
				// 				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				// 				tubeVisualList.push( tube.tubeVisual )
				// 				tubeBodiesList.push( tube.hingeBodies )
				// 				deflationTubes.push( tube )
				// 			}
							
				// 			if( testObj.tube== "normal" ) {
				// 				var tubeType = 0
				// 				var connectorIndex = i
				// 				var angleIndex = testObj.angle
				// 				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				// 				tubeVisualList.push( tube.tubeVisual )
				// 				tubeBodiesList.push( tube.hingeBodies )
				// 				deflationTubes.push( tube )
				// 			}

				// 		}
				// 	}
				// }
				
				if ( controltype.type == 'edit' ) {
					if( testObj2.type=="delete" ){
						
						for ( let i = 0; i<tubeNum; i++ ) {
							const hits = raycaster.intersectObject( tubeVisualList[i] )
							if (hits.length > 0) {
								if(hits[ 0 ].object.name=="floor"){
									hit.pop()
								}
							}
							if (hits.length > 0) {
								
								if (hits[0].object.parent.type == "Group"){
									console.log(hits[0].object.parent)
									hits[0].object.parent.traverse(function(obj){		
																	
											if (obj.type === 'Mesh') {
											obj.geometry.dispose();
											obj.material.dispose();
										}
									})
									scene.remove(hits[0].object.parent);
									console.log(tubeVisualList)	
									console.log(tubeBodiesList)
									console.log(bodies)	
									console.log(visuals)
									//还需删除connector 这么通过tube索引connector 和 判定需要删除connnect的条件
								}
							}
						}
					}
				}

				//分组功能 通过改变tube.parent.name实现索引分组 //body未完成
				if (inGroupmode(controltype.type)){
					
					for ( let i = 0; i<tubeNum; i++ ) {
							const hits = raycaster.intersectObject( tubeVisualList[i] )
							if (hits.length > 0) {
								if(hits[ 0 ].object.name=="floor"){
									hit.splice(0,hit.length)
								}
							}
							if (hits.length > 0) {
								if (hits[0].object.parent.type == "Group"){
									if(hits[0].object.parent.name != controltype.type){
										hits[0].object.parent.name = controltype.type
										console.log(hits[0].object.parent)
										break;
									}
									if(hits[0].object.parent.name == controltype.type){
										hits[0].object.parent.name=''
										console.log(hits[0].object.parent)
										break;
									}	
								}
							}							
					}
				}
				
			})
			
			function connectTube() {
				/**
				 * Initialize a default connector in the physical world and visualize it in the scene
				 * Get parameters from the user interface
				 * Let users manipulate tubes in the scene by selecting the connector and pre-defined angles
				*/
				const defaultConnector = initDefaultConnector()
				connectorBodies.push( defaultConnector )
				bodyToMesh( defaultConnector ).forEach( (mesh) => {
					scene.add( mesh )
					connectorMeshes.push( mesh )
				})
				
				var tubeType = 0
				var connectorIndex = 0
				var angleIndex = 0
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeVisualList.push( tube.tubeVisual )
				tubeBodiesList.push( tube.hingeBodies )
				deflationTubes.push( tube )
				
				var tubeType = 0
				var connectorIndex = 0
				var angleIndex = 1
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeVisualList.push( tube.tubeVisual )
				tubeBodiesList.push( tube.hingeBodies )
				deflationTubes.push( tube )
				
				var tubeType = 0
				var connectorIndex = 1
				var angleIndex = 2
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeVisualList.push( tube.tubeVisual )
				tubeBodiesList.push( tube.hingeBodies )
				deflationTubes.push( tube )

				var tubeType = 0
				var connectorIndex = 1
				var angleIndex = 0
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeVisualList.push( tube.tubeVisual )
				tubeBodiesList.push( tube.hingeBodies )
				deflationTubes.push( tube )

				var tubeType = 0
				var connectorIndex = 2
				var angleIndex = 0
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeVisualList.push( tube.tubeVisual )
				tubeBodiesList.push( tube.hingeBodies )
				deflationTubes.push( tube )
		
			}
			
			function addMiuraTube( tubeType, connectorIndex, angleIndex ) {
				/**
				 * Initiate a new physical tube with customized position and quaternion
				 * Treat a new miura-ori tube as a three.js group and render
				 * Automatically add connector bodies to the tube
				 * tubeType is 0 => straight miura-ori tube; tubeType is 1 => bending miura-ori tube
				*/
				
				// Calculate position and quaternion according to the connectorIndex and angleIndex
				const quaternion = new CANNON.Quaternion()
				
				if ( angleIndex == 0 ) {
					// Pre-defined angles
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), 0 )
				} else if ( angleIndex == 1 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), Math.PI/3 )
				} else if ( angleIndex == 2 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), Math.PI/3*2 )
				} else if ( angleIndex == 3 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), Math.PI )
				}
				
				// Copy pivot connector position
				const position = new CANNON.Vec3().copy( connectorBodies[connectorIndex].position )
				
				const intervalDistance = 12.954878  // half width of the Miura-ori tube unit
				const sphereRadius = 15.0  // connector bounding sphere radius
				const unitVec = new CANNON.Vec3( sphereRadius + intervalDistance, 0, 0 )
				quaternion.vmult( unitVec, unitVec )
				position.vadd( unitVec, position )
				
				// Render tube physical bodies to the view based on customized position and quaternion
				if ( tubeType == 0 ) {
					// straight miura-ori tube
					var tubeInfo = initDefaultMiuraTube( position, quaternion )
				} else if ( tubeType == 1 ) {
					// bending miura-ori tube
					var tubeInfo = initBendingMiuraTube( position, quaternion )
				}
				
				const hingeBodies = tubeInfo.hingeBodiesArray
				const hingeConstraints = tubeInfo.constraints
				
				const tubeVisual = new THREE.Group()
				hingeBodies.forEach( (body, i) => {
					const meshes = bodyToMesh( body )
					meshes.forEach( (mesh) => { tubeVisual.add( mesh ) } )
				})
				scene.add(tubeVisual)
				
				// Automatically add new connector body to the scene
				const newConnector = attachConnector( connectorIndex, hingeBodies, unitVec )
				if ( newConnector != undefined ) {
					connectorBodies.push( newConnector )
					bodyToMesh( newConnector ).forEach( (mesh) => {
						scene.add( mesh )
						connectorMeshes.push( mesh )
					})
				}
				
				return {tubeVisual, hingeBodies, hingeConstraints}
			}
			
			function initDefaultConnector() {
				/**
				 * Initialize a default connector in the physical world
				*/
				const sphereRadius = 15
				const sphereShape = new CANNON.Sphere(sphereRadius)
				
				const defaultConnector = new CANNON.Body({
					mass: 0.1,
					type: CANNON.Body.DYNAMIC,
					shape: sphereShape,
					position: new CANNON.Vec3(0,0,0)
				})
				
				// No collision needed
				defaultConnector.collisionFilterGroup = 0
				defaultConnector.collisionFilterMask = 0
				world.addBody(defaultConnector)
				
				return defaultConnector
			}
			
			function attachConnector( connectorIndex, hingeBodies, unitVec ) {
				/**
				 * Add lock constraints between the selected connector and hinge bodies
				 * Attach a new connector to the end of the tube
				*/
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[0] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[2] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[4] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[6] ))
				
				// Pre-defined tube bounding box dimensions: length => 155.458538, width => 37.288780, height => 17.527490
				const bBoxLength = 155.458538
				const bBoxWidth = 37.288780
				const bBoxHeight = 17.527490
				
				const sphereRadius = 15
				const sphereShape = new CANNON.Sphere(sphereRadius)
				// const boxShape = new CANNON.Box(new CANNON.Vec3(10,10,10))
				
				const newPos = unitVec.unit()
				const distance = bBoxLength + sphereRadius * 2
				newPos.scale( distance, newPos )
				newPos.vadd( connectorBodies[connectorIndex].position, newPos )
				
				// Set a flag: True => Add a new connector; Flase => Do not add
				let flag = true
				
				// Check if there is a existing connector in the new position
				for ( let i=0; i<connectorBodies.length; i++ ) {
					const vecEqual = newPos.almostEquals( connectorBodies[i].position )
					if ( vecEqual == true ) {
						flag = false
						
						// Add lock constraints between the exsiting connector and hinge bodies
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-1] ))
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-3] ))
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-5] ))
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-7] ))
					}
				}
				
				if ( flag == false ) {
					return undefined
				} else {
					// Attach a new connector to the end of the tube
					const newConnector = new CANNON.Body({
						mass: 0.1,
						type: CANNON.Body.DYNAMIC,
						shape: sphereShape,
						position: newPos
					})
					newConnector.collisionFilterGroup = 0
					newConnector.collisionFilterMask = 0
					world.addBody(newConnector)
					
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-1] ))
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-3] ))
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-5] ))
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-7] ))
					
					return newConnector
				}
			}
			
			function initDefaultMiuraTube( position, quaternion ) {
				/**
				 * Store face coordinates from the Grasshopper file with 0.65 folding ratio
				 * Store vertices and indices for the body and geometry of the miura-ori tube
				 * Initiate the physical miura-ori tube with Trimesh shape
				 * Specify hinge constraints with axis and pivot point
				*/				
				const faceVertices_1 = new Float32Array([
					0, 0, 0,
					0, 12.173610, 8.763745,
					-12.95488, -0.768048, 8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_2 = new Float32Array([
					0, 0, 0,
					12.95488, -12.941658, 0,
					12.954878, -0.768048, 8.763745,
					0, 12.173610, 8.763745
				])
				const faceVertices_3 = new Float32Array([
					0, 12.173610, 8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, 8.763745
				])
				const faceVertices_4 = new Float32Array([
					0, 12.173610, 8.763745,
					12.954878, -0.768048, 8.763745,
					12.954878, 11.405561, 0,
					0, 24.347219, 0
				])
				const faceVertices_5 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					-12.954878, -0.768048, -8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_6 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					12.954878, -0.768048, -8.763745,
					12.954878, -12.941658, 0
				])
				const faceVertices_7 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, -8.763745
				])
				const faceVertices_8 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					12.954878, 11.405561, 0,
					12.954878, -0.768048, -8.763745
				])
				
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				// Number of faces in a miura-ori unit
				const unitNumber = 6	// a miura-ori tube has 6 units
				const unitFacesNum = 8  // a unit has 8 quadrilaterals
				let hingeBodiesArray = new Array( unitNumber * unitFacesNum )
				const mass = 1
				
				// Set the quaternion of the intervalVec
				const intervalDistance = 12.954878 * 2
				const intervalVec = new CANNON.Vec3( intervalDistance, 0, 0 )
				const intervalQuat = new CANNON.Quaternion().copy( quaternion )	// Rotate the intervalVec
				intervalQuat.vmult( intervalVec, intervalVec )
				
				// Whether to add hinge constraints (for test)
				const useHingeConstraints = true
				let constraints = []
				
				// Initiatize hinge bodies with shape, position, and quaternion
				for ( let i = 0; i < unitNumber; i++ ) {
                    hingeBodiesArray[ i*unitFacesNum ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum ] )
                    
					hingeBodiesArray[ i*unitFacesNum+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+1 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+2 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+3 ] )

					hingeBodiesArray[ i*unitFacesNum+4 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_5, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+4 ] )
					
					hingeBodiesArray[ i*unitFacesNum+5 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_6, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+5 ] )

					hingeBodiesArray[ i*unitFacesNum+6 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_7, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+6 ] )
					
					hingeBodiesArray[ i*unitFacesNum+7 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_8, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+7 ] )
                }
				
				// Specify a list of hinge constraints
				if (useHingeConstraints) {
					for ( let i = 0; i < unitNumber; i++ ) {
						const axis1 = new CANNON.Vec3( 0, 0.811574, 0.58425 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+1 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis1,	
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis1,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis2 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+2 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis2,
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis2,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis3 = new CANNON.Vec3( 0.707468, -0.706746, 0 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis3,
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis3,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis4 = new CANNON.Vec3( 0, -0.811574, 0.58425 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis4,	
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis4,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis5 = new CANNON.Vec3( 0, -0.811574, 0.58425 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis5,	
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis5,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis6 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis6,
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis6,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis7 = new CANNON.Vec3( -0.707468, 0.706746, 0 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis7,
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis7,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis8 = new CANNON.Vec3( 0, 0.811574, 0.58425 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+6 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis8,	
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis8,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis9 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+4 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis9,
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis9,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis10 = new CANNON.Vec3( 0.707468, -0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis10,
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis10,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis11 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisA: axis11,
								pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisB: axis11,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis12 = new CANNON.Vec3( -0.707468, 0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisA: axis12,
								pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisB: axis12,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						// Specify hinge constraints to connect multiple units
						if ( i < unitNumber -1 ) {
							const axis13 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // mountain hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ (i+1)*unitFacesNum ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
									axisA: axis13,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
									axisB: axis13,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis14 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // vally hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ (i+1)*unitFacesNum+2 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
									axisA: axis14,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
									axisB: axis14,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis15 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // mountain hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ (i+1)*unitFacesNum+4 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
									axisA: axis15,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
									axisB: axis15,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis16 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // vally hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+7], hingeBodiesArray[ (i+1)*unitFacesNum+6 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
									axisA: axis16,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
									axisB: axis16,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
						}
					}
				}

				const stiffness = 1e10
				const relaxation = 0.5
				const timeStep = 1/60
				
				// Add the constraints to the world and enable hinge motor, each tube has 92 hinge constraints
				constraints.forEach( function( constraint ) {
					constraint.equations.forEach(function( equation ) {
						// set greater stiffness on the hinge
						equation.setSpookParams( stiffness, relaxation, timeStep )
					})
					
					constraint.enableMotor()
					constraint.setMotorSpeed( initialHingeVelocity )
					world.addConstraint( constraint )
				})
				
				return {hingeBodiesArray, constraints}
			}
			
			function initBendingMiuraTube( position, quaternion ) {
				// Initiate a physical miura-ori tube with bending simulation
				const faceVertices_1 = new Float32Array([
					0, 0, 0,
					0, 12.173610, 8.763745,
					-12.95488, -0.768048, 8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_2 = new Float32Array([
					0, 0, 0,
					12.95488, -12.941658, 0,
					12.954878, -0.768048, 8.763745,
					0, 12.173610, 8.763745
				])
				const faceVertices_3 = new Float32Array([
					0, 12.173610, 8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, 8.763745
				])
				const faceVertices_4 = new Float32Array([
					0, 12.173610, 8.763745,
					12.954878, -0.768048, 8.763745,
					12.954878, 11.405561, 0,
					0, 24.347219, 0
				])
				const faceVertices_5 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					-12.954878, -0.768048, -8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_6 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					12.954878, -0.768048, -8.763745,
					12.954878, -12.941658, 0
				])
				const faceVertices_7 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, -8.763745
				])
				const faceVertices_8 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					12.954878, 11.405561, 0,
					12.954878, -0.768048, -8.763745
				])
				
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				// Number of faces in a miura-ori unit
				const unitNumber = 6	// a miura-ori tube has 6 units
				const unitFacesNum = 8  // a unit has 8 quadrilaterals
				let hingeBodiesArray = new Array( unitNumber * unitFacesNum )
				const mass = 1
				
				// Set the quaternion of the intervalVec
				const intervalDistance = 12.954878 * 2
				const intervalVec = new CANNON.Vec3( intervalDistance, 0, 0 )
				const intervalQuat = new CANNON.Quaternion().copy( quaternion )	// Rotate the intervalVec
				intervalQuat.vmult( intervalVec, intervalVec )
				
				// Whether to add hinge constraints (for test)
				const useHingeConstraints = true
				let constraints = []
				
				// Initiatize hinge bodies with shape, position, and quaternion
				for ( let i = 0; i < unitNumber; i++ ) {
                    hingeBodiesArray[ i*unitFacesNum ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum ] )
                    
					hingeBodiesArray[ i*unitFacesNum+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+1 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+2 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+3 ] )

					hingeBodiesArray[ i*unitFacesNum+4 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_5, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+4 ] )
					
					hingeBodiesArray[ i*unitFacesNum+5 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_6, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+5 ] )

					hingeBodiesArray[ i*unitFacesNum+6 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_7, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+6 ] )
					
					hingeBodiesArray[ i*unitFacesNum+7 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_8, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+7 ] )
                }
				
				// Assign different stiffness, relaxation to two groups of hinge constraints
				const stiffness_1 = 1e6
				const relaxation_1 = 0.5
				const stiffness_2 = 1e10
				const relaxation_2 = 0.8
				const timeStep = 1/60
				const initialHingeVelocity_1 = -Math.PI / 0.55
				const initialHingeVelocity_2 = Math.PI / 0.3
				
				// Specify a list of hinge constraints
				if (useHingeConstraints) {
					for ( let i = 0; i < unitNumber; i++ ) {
						const axis1 = new CANNON.Vec3( 0, 0.811574, 0.58425 ) // vally hinge
						const hinge1 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+1 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis1,	
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis1,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge1.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_2, relaxation_2, timeStep )
						})
						hinge1.enableMotor()
						hinge1.setMotorSpeed( initialHingeVelocity_2 )
						world.addConstraint( hinge1 )
						constraints.push( hinge1 )
						
						const axis2 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // mountain hinge
						const hinge2 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+2 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisA: axis2,
							pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisB: axis2,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge2.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
						})
						hinge2.enableMotor()
						hinge2.setMotorSpeed( initialHingeVelocity_1 )
						world.addConstraint( hinge2 )
						constraints.push( hinge2 )
						
						const axis3 = new CANNON.Vec3( 0.707468, -0.706746, 0 )	// mountain hinge
						const hinge3 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisA: axis3,
							pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisB: axis3,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge3.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
						})
						hinge3.enableMotor()
						hinge3.setMotorSpeed( initialHingeVelocity_1 )
						world.addConstraint( hinge3 )
						constraints.push( hinge3 )
						
						const axis4 = new CANNON.Vec3( 0, -0.811574, 0.58425 )	// mountain hinge
						const hinge4 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis4,	
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis4,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
						})
						
						hinge4.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
						})
						hinge4.enableMotor()
						hinge4.setMotorSpeed( initialHingeVelocity_1 )
						world.addConstraint( hinge4 )
						constraints.push( hinge4 )
						
						const axis5 = new CANNON.Vec3( 0, -0.811574, 0.58425 ) // vally hinge
						const hinge5 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis5,	
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis5,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge5.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_2, relaxation_2, timeStep )
						})
						hinge5.enableMotor()
						hinge5.setMotorSpeed( initialHingeVelocity_2 )
						world.addConstraint( hinge5 )
						constraints.push( hinge5 )
						
						const axis6 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // mountain hinge
						const hinge6 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisA: axis6,
							pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisB: axis6,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge6.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
						})
						hinge6.enableMotor()
						hinge6.setMotorSpeed( initialHingeVelocity_1 )
						world.addConstraint( hinge6 )
						constraints.push( hinge6 )
						
						const axis7 = new CANNON.Vec3( -0.707468, 0.706746, 0 )	// mountain hinge
						const hinge7 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisA: axis7,
							pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisB: axis7,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge7.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
						})
						hinge7.enableMotor()
						hinge7.setMotorSpeed( initialHingeVelocity_1 )
						world.addConstraint( hinge7 )
						constraints.push( hinge7 )
						
						const axis8 = new CANNON.Vec3( 0, 0.811574, 0.58425 )	// mountain hinge
						const hinge8 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+6 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisA: axis8,	
							pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisB: axis8,	
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge8.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
						})
						hinge8.enableMotor()
						hinge8.setMotorSpeed( initialHingeVelocity_1 )
						world.addConstraint( hinge8 )
						constraints.push( hinge8 )
						
						const axis9 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // vally hinge
						const hinge9 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+4 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis9,
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis9,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge9.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_2, relaxation_2, timeStep )
						})
						hinge9.enableMotor()
						hinge9.setMotorSpeed( initialHingeVelocity_2 )
						world.addConstraint( hinge9 )
						constraints.push( hinge9 )
						
						const axis10 = new CANNON.Vec3( 0.707468, -0.706746, 0 ) // vally hinge
						const hinge10 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis10,
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis10,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge10.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_2, relaxation_2, timeStep )
						})
						hinge10.enableMotor()
						hinge10.setMotorSpeed( initialHingeVelocity_2 )
						world.addConstraint( hinge10 )
						constraints.push( hinge10 )
						
						const axis11 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // vally hinge
						const hinge11 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
							pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisA: axis11,
							pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisB: axis11,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge11.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_2, relaxation_2, timeStep )
						})
						hinge11.enableMotor()
						hinge11.setMotorSpeed( initialHingeVelocity_2 )
						world.addConstraint( hinge11 )
						constraints.push( hinge11 )
						
						const axis12 = new CANNON.Vec3( -0.707468, 0.706746, 0 ) // vally hinge
						const hinge12 =	new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
							pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisA: axis12,
							pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisB: axis12,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						
						hinge12.equations.forEach( function( equation ) {
							equation.setSpookParams( stiffness_2, relaxation_2, timeStep )
						})
						hinge12.enableMotor()
						hinge12.setMotorSpeed( initialHingeVelocity_2 )
						world.addConstraint( hinge12 )
						constraints.push( hinge12 )
						
						// Specify hinge constraints to connect multiple units
						if ( i < unitNumber -1 ) {
							const axis13 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // mountain hinge
							const hinge13 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ (i+1)*unitFacesNum ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
								axisA: axis13,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
								axisB: axis13,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							
							hinge13.equations.forEach(function( equation ) {
								equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
							})
							hinge13.enableMotor()
							hinge13.setMotorSpeed( initialHingeVelocity_1 )
							world.addConstraint( hinge13 )
							constraints.push( hinge13 )
							
							const axis14 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // vally hinge
							const hinge14 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ (i+1)*unitFacesNum+2 ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
								axisA: axis14,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
								axisB: axis14,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							
							hinge14.equations.forEach(function( equation ) {
								equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
							})
							hinge14.enableMotor()
							hinge14.setMotorSpeed( initialHingeVelocity_1 )
							world.addConstraint( hinge14 )
							constraints.push( hinge14 )
							
							const axis15 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // mountain hinge
							const hinge15 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ (i+1)*unitFacesNum+4 ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
								axisA: axis15,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
								axisB: axis15,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							hinge15.equations.forEach( function( equation ) {
								equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
							})
							hinge15.enableMotor()
							hinge15.setMotorSpeed( initialHingeVelocity_1 )
							world.addConstraint( hinge15 )
							constraints.push( hinge15 )
							
							const axis16 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // vally hinge
							const hinge16 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+7], hingeBodiesArray[ (i+1)*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
								axisA: axis16,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
								axisB: axis16,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							hinge16.equations.forEach( function( equation ) {
								equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
							})
							hinge16.enableMotor()
							hinge16.setMotorSpeed( initialHingeVelocity_1 )
							world.addConstraint( hinge16 )
							constraints.push( hinge16 )
						}
					}
				}
				return {hingeBodiesArray, constraints}
			}

			function initFlatMiuraTube() {
				/**
				 * Note that this function folds the tube from a flat surface
				 * Store vertices and indices for the geometry of miura-ori tube
				 * Initiate the physical miura-ori tube with Trimesh shape
				 * Specify hinge constraints with axis and pivot point
				*/
				const faceVertices_1 = new Float32Array([
					0, -15, 0,
					0, 0, 0, 
					-15.0, -10.503123, 0,
					-15.0, -25.503113, 0
				])
				const faceVertices_2 = new Float32Array([
					0, -15, 0,	
					15.0, -25.503113, 0,
					15.0, -10.503123, 0,
					0, 0, 0
				])
				const faceVertices_3 = new Float32Array([
					0, 0, 0,
					0, 15.0, 0,
					-15.0, 4.496877, 0,
					-15.0, -10.503123, 0
				])
				const faceVertices_4 = new Float32Array([
					0, 0, 0,
					15.0, -10.503123, 0,
					15.0, 4.496877, 0,
					0, 15.0, 0
				])
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				const mass = 10
				const intervalDistance = 15.0 * 2
				
				// Define hinge bodies
				for (let i = 0; i < unitNumber; i++) {
                    hingeBodiesArray[ i*4 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4 ] )
                    
					hingeBodiesArray[ i*4+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+1 ] )
                    
					hingeBodiesArray[ i*4+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+2 ] )
                    
					hingeBodiesArray[ i*4+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+3 ] )
                }
				
				// Specify a list of constraints
				for (let i = 0; i < unitNumber; i++) {
					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4 ], hingeBodiesArray[ i*4+1 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0, 1, 0), // vally hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0, 1, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4 ], hingeBodiesArray[ i*4+2 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0.819252, 0.573576, 0), // mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0.819252, 0.573576, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4+1 ], hingeBodiesArray[ i*4+3 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0.819252, -0.573576, 0),	// mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0.819252, -0.573576, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4+2 ], hingeBodiesArray[ i*4+3 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0,-1,0),	// mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0,-1,0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)
					
					if ( i < unitNumber -1 ) {
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*4+1 ], hingeBodiesArray[ (i+1)*4 ], {
								pivotA: new CANNON.Vec3(15, 0, 0),
								axisA: new CANNON.Vec3(0, -1, 0), // mountain hinge
								pivotB: new CANNON.Vec3(-15, 0, 0),
								axisB: new CANNON.Vec3(0, -1, 0),
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*4+3 ], hingeBodiesArray[ (i+1)*4+2 ], {
								pivotA: new CANNON.Vec3(15, 0, 0),
								axisA: new CANNON.Vec3(0, 1, 0), // vally hinge 
								pivotB: new CANNON.Vec3(-15, 0, 0),
								axisB: new CANNON.Vec3(0, 1, 0),
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
					}
				}
				
				const stiffness = 1e10
				const relaxation = 4
				const timeStep = 1/60
				// add the constraints to the world and enable hinge motor
				constraints.forEach( function( constraint ) {
					constraint.equations.forEach(function( equation ) {
						// set greater stiffness on the hinge
						equation.setSpookParams( stiffness, relaxation, timeStep )
					})
					
					constraint.enableMotor()
					constraint.setMotorSpeed( initialHingeVelocity )
					world.addConstraint( constraint )
				})
			}
			
			function initCannon() {
				world = new CANNON.World()
				world.solver.iterations = 50
				world.quatNormalizeFast = true
				
				// Set the gravity vector
				if (useGravity == true) {
					world.gravity.set(0, -9.82, 0)
				}
				
				// Create a static ground
				const groundBody = new CANNON.Body({
					type: CANNON.Body.Static,
					shape: new CANNON.Plane(),
					material: new CANNON.Material('ground')
				})
				
				// Visualization of the plane geometry is defined in initThree()
				groundBody.quaternion.setFromEuler( -Math.PI / 2, 0, 0 )
				groundBody.position.set( 0, -60, 0 )
				world.addBody(groundBody)
			}
			
			function bodyToMesh( body ) {
				/**
				 * Convert cannon bodies to three.js meshes directly
				*/
				if ( !(body instanceof CANNON.Body) ) {
					throw new Error('The argument passed to bodyToMesh() is not a body')
				}

				// Materials
				const basicMaterial = new THREE.MeshBasicMaterial( {color: 0x44aa88, side: THREE.DoubleSide, wireframe: false} )
				const phongMaterial = new THREE.MeshPhongMaterial( {color: 0x44aa88, side: THREE.DoubleSide, wireframe: false} )
				const normalMaterial = new THREE.MeshNormalMaterial( {side: THREE.DoubleSide, wireframe: false} )

				const lambertMaterial = new THREE.MeshLambertMaterial( { color:  0xff5fff } )
				const material = lambertMaterial
				// const colors = new Float32Array()
				
				// Get the mesh of body
				const meshes = body.shapes.map( (shape) => {
					switch (shape.type) {
						// check the shape type
						case CANNON.Shape.types.TRIMESH: {
							const verticeNum = shape.indices.length * 3
							const v0 = new CANNON.Vec3()
							const v1 = new CANNON.Vec3()
							const v2 = new CANNON.Vec3()
							
							const geometry = new THREE.BufferGeometry()
							const vertices = new Float32Array( verticeNum )
							const indices = new Uint16Array( shape.indices.length )
							let posNdx = 0
							
							for ( let i = 0; i < shape.indices.length / 3; i++ ) {
								shape.getTriangleVertices( i, v0, v1, v2 )
								
								const positions = [v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z]
								posNdx = posNdx + i * 3 * 3
								vertices.set( positions, posNdx )
								indices.set( [i*3, i*3+1, i*3+2], i * 3 )
							}
							// console.log(vertices)
							// console.log(indices)
							geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3) )
							geometry.setIndex( new THREE.BufferAttribute(indices, 1) )
							
							geometry.computeBoundingSphere()
							geometry.computeVertexNormals()
							
							return new THREE.Mesh( geometry, material )
						}
						
						case CANNON.Shape.types.SPHERE: {
							const geometry = new THREE.SphereGeometry( shape.radius )
							return new THREE.Mesh( geometry, material )
						}
						
						case CANNON.Shape.types.BOX: {
							const geometry = new THREE.BoxGeometry( shape.halfExtents.x * 2, shape.halfExtents.y * 2, shape.halfExtents.z * 2 )
							return new THREE.Mesh( geometry, material )
						}
					}
				})
				
				// In case multiple shapes in one body (compound body)
				meshes.forEach( (mesh, i) => {
					// console.log(mesh)
					mesh.position.copy( body.shapeOffsets[i] )
					mesh.quaternion.copy( body.shapeOrientations[i] )
					// Enable shadows on every object
					mesh.receiveShadow = true
    				mesh.castShadow = true
					
					// For function animation()
					bodies.push(body)
					visuals.push(mesh)
				})
				return meshes
			}
			
			function initThree() {
				THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 )
				
				// Renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } )
				renderer.setPixelRatio( window.devicePixelRatio )
				renderer.setSize( window.innerWidth, window.innerHeight )
				renderer.outputEncoding = THREE.sRGBEncoding
				document.body.appendChild( renderer.domElement )
				renderer.shadowMap.enabled = true
    			renderer.shadowMap.type = THREE.PCFSoftShadowMap
				
				renderer.shadowMap.enabled = true
        		renderer.shadowMap.type = THREE.PCFSoftShadowMap
				
				// Camera
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )
				camera.position.set( 0, 500, 400 )

				// Scene
				scene = new THREE.Scene()
				scene.background = new THREE.Color( 'rgb(240, 240, 240)' )
				
				// Lights
				scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.1 ) )
				const directionalLight = new THREE.DirectionalLight( 0xFFFFFF, 2 )
				directionalLight.position.set( -30, 40, 30 )
				directionalLight.target.position.set( 0, 0, 0 )
				scene.add( directionalLight )
				
				// Floor
				const floorGeometry = new THREE.PlaneGeometry( 5000, 5000, 100, 100 )
				floorGeometry.rotateX( -Math.PI / 2 )
				const floorMaterial = new THREE.MeshLambertMaterial( { color: 0x787878 } )
				const floor = new THREE.Mesh( floorGeometry, floorMaterial )
				floor.name = "floor"
				floor.position.set( 0, -60, 0 )
				floor.receiveShadow = true
				// scene.add(floor)
				
				const gridHelper = new THREE.GridHelper( 2000, 50 )
				gridHelper.position.set( 0, -60, 0 )
				gridHelper.name = "floor"
				scene.add( gridHelper )
				
				// Orbit controls
				controls = new OrbitControls( camera, renderer.domElement )
				window.addEventListener( 'resize', onWindowResize )
				controls.rotateSpeed = 0.8
				controls.zoomSpeed = 0.2
				controls.enableDamping = true
				controls.enablePan = true
				controls.dampingFactor = 0.2
				controls.minDistance = 10
				controls.maxDistance = 500
			}
			
			function animate() {
				requestAnimationFrame( animate )
				
				// Step the physical simulation forward
				world.fixedStep()
				
				// update the position and orientation of the mesh to match the CannonBody
				for ( let i = 0; i < bodies.length; i++ ) {
					const body = bodies[i]
					const visual = visuals[i]
					visual.position.copy( bodies[i].position )
        			visual.quaternion.copy( bodies[i].quaternion )
				}
				
				// Stop hinge bodies folding through each other while deflation
				stopFacesFoldThrough( deflationTubes )
				
				// Prevent the tube from becoming a flat surface while inflation
				stopInflation()
				
				// Render three.js objects
				controls.update()
				renderer.render( scene, camera )
			}
			
			function deflateTube( deflationTubes ) {
				// Give velocity to hingeConstraints
				const velocity = foldingVelocity
				
				for ( let i = 0; i < deflationTubes.length; i++ ) {
					deflationTubes[i].hingeConstraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				}
				
				// setTimeout(() => {
				// 	const velocity = 0
				// 	constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				// }, foldingDuration)
			}
			
			function stopFacesFoldThrough( deflationTubes ) {
				// Stop hinge bodies folding through each other by setting minimum distance while deflation
				for ( let i = 0; i < deflationTubes.length; i++ ) {
					const refBody1 = deflationTubes[i].hingeBodies[17]
					const refBody2 = deflationTubes[i].hingeBodies[25]
					
					if ( refBody1.position.distanceSquared( refBody2.position ) < disSquMin ) {
						deflationTubes[i].hingeBodies.forEach( body => body.sleep() )
					}
				}
			}
			
			function inflateTube() {
				const velocity = unfoldingVelocity
				constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				
				// setTimeout(() => {
				// 	const velocity = 0
				// 	constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				// }, unFoldingDuration)
			}
			
			function stopInflation( inflationConstraints ) {
				// Prevent the tube from becoming a flat surface while inflation
				if ( bodies[1].position.distanceSquared(bodies[9].position) >= disSquMax ) {
					const velocity = Math.PI / 1000
					console.log("stopInflation")
					console.log(velocity)
					constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				}
			}
			
			function onWindowResize() {
				const width = window.innerWidth
				const height = window.innerHeight
				camera.aspect = width / height
				camera.updateProjectionMatrix()
				renderer.setSize( width, height )
			}
			
			function render() {
				//hlight 不同的airchannel

				if (inGroupmode(controltype.type)){
					var a = parseInt(controltype.type.substr(-1))-1
					// console.log(color[a])
					tubeVisualList.forEach((object)=>{
						if(object.name == controltype.type){							
							object.children.forEach( (mesh) => {
								mesh.material.emissive.setHex(color[a]);
								// console.log(object.children)
							})
						}
						else{
							object.children.forEach( (mesh) => {
								mesh.material.emissive.setHex(0xff5fff );
								// console.log(object.children)
							})
						}
					})
				}


				// 指针放上去highlight
				const mouse = new THREE.Vector2()
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1
        		mouse.y = -(( event.clientY / window.innerHeight ) * 2 - 1)
				
				// Get the picking ray from the point
				const raycaster = new THREE.Raycaster()
				raycaster.setFromCamera( mouse, camera )
				// console.log(INTERSECTED)
				// 计算物体和射线的焦点
				const intersects = raycaster.intersectObjects( scene.children );
				// console.log(intersects.length)
				if ( intersects.length > 0 ) {
					if(intersects[ 0 ].object.name=="floor"){
							intersects.splice(0,intersects.length)
						}
				}
				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						// console.log(intersects[ 0 ].object)

						if ( INTERSECTED ) {
								if (INTERSECTED.parent.type =="Group"){
									INTERSECTED.parent.children.forEach( (mesh) => {
										mesh.material.emissive.setHex(INTERSECTED.currentHex );
								})
								}
								else{
									INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
								}
								
							}

							INTERSECTED = intersects[ 0 ].object;
							INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
							if (INTERSECTED.parent.type =="Group"){
								// console.log(INTERSECTED.parent.type)
								INTERSECTED.parent.children.forEach( (mesh) => {
									mesh.material.emissive.setHex( 0xff0000 );
								})
							}
							else {
								INTERSECTED.material.emissive.setHex( 0xff0000 );
							}

					}

					} else {

						if ( INTERSECTED ){
							
							if (INTERSECTED.parent.type =="Group"){
									
									INTERSECTED.parent.children.forEach( (mesh) => {
										mesh.material.emissive.setHex(INTERSECTED.currentHex );
									})
							}
							else{
								INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
							}
						
						} 

						INTERSECTED = null;

				}			
				
				// renderer.render( scene, camera );
			}
			window.addEventListener( 'pointermove', render );
		</script>
	</body>
</html>
