<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Origami Actuators</title>
		<!-- <link rel="stylesheet" href="css/style.css" type="text/css" /> -->
		<style>
			body { margin: 0; }
			.lil-gui {
				--font-size: 16px;
				--input-font-size: 16px;
				--widget-height: 35px;
				--width: 400px;
			}
			.control-inactive button {
				color: #888;
			}
			.control-inactive1 button {
				color: #4E978F;
			}
			.control-inactive2 button {
				color: #43CD80;
			}
			.control-inactive3 button {
				color: #E7959F;
			}
			.control-inactive4 button {
				color: #FFCD8D;
			}
			/* .control-inactive5 button {
				color: #4E978F;
			}
			.control-inactive6 button {
				color: #4E978F;
			} */
		</style>
	</head>
	
	<body>
		<!-- <script src="../node_modules/three/build/three.min.js"></script> -->
		<script type="importmap">
			{
				"imports": {
					"three": "../node_modules/three/build/three.module.js",
					"three/addons/": "../node_modules/three/examples/jsm/",
					"cannon-es": "../node_modules/cannon-es/dist/cannon-es.js"
				}
			}
		</script>
		
        <script type="module">
			import * as THREE from 'three'
			import * as CANNON from 'cannon-es'
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js'
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
			import { TransformControls } from 'three/addons/controls/TransformControls.js'
			
			/**
			 * Todo List:
			 * Step1: Reset folding ratio to 0.75 (CZT)
			 * Change tube type
			 * Add actuator one by one
			 * Add basic primitive shape
			 * Arduino communication (JX)
			*/
			
			// Three.js variables for render
			let renderer, camera, scene
			let controls, transControl
			
			// Cannon.js variables for physical simulation
			let world
			let useGravity = false
			
			// Set hinge motor velocity that determines speed and direction
			const initialHingeVelocity = 0
			const foldingVelocity = Math.PI / 1.5
			const foldingDuration = 1600
			const unfoldingVelocity = - Math.PI / 4
			const unFoldingDuration = 3000
			const disSquMinLinear = 120
			const disSquMinBending = 120
			const disSquMaxLinear = 720
			
			// Keep in sync the bodies with the visuals, they always have the same length
			let bodies = []
			let visuals = []
			
			// User interaction variables
			let tubeInfoList = []
			let connectorMeshes = []
			let connectorBodies = []
			
			let deflationActuators = []
			let inflationActuators = []
			
			let airChannels = [] 
			let initColor = 4539717
			let colors = [5948868,5150607,4443520,15177119,16764301] //color
			let buttons = [] 
			let startTimes = [] //move start time 
			let endTimes = [] //move end time
			let actuationMethods = [] //kind of move
			let changeFlag = 0 //highlight
			let maxEnd = 1 //max time for loop
			let moved = [] //move flag  

			//	clock		
			var count = 0
			var timeCount

			//init control varablies
			airChannels.push("-----")
			airChannels.push("Airchannel 1")
			airChannels.push("Airchannel 2")
			actuationMethods.push('Deflation')
			actuationMethods.push('Deflation')
			actuationMethods.push('Deflation')
			startTimes.push(0)
			startTimes.push(0)
			startTimes.push(0)
			endTimes.push(1)
			endTimes.push(1)
			endTimes.push(1)
			moved.push(0)
			moved.push(0)
			moved.push(0)

			// GUI settings
			const gui = new GUI()
			var controlType = null
			let refBoxMesh
			let last_deg_x, last_deg_y, last_deg_z

			const axis = [new CANNON.Vec3(1, 0, 0), new CANNON.Vec3(0, 1, 0), new CANNON.Vec3(0, 0, 1)]
			const angle = [0, 30*Math.PI/180, 45*Math.PI/180, 60*Math.PI/180, 75*Math.PI/180, 90*Math.PI/180, 120*Math.PI/180, 135*Math.PI/180, 150*Math.PI/180, 165*Math.PI/180, Math.PI]
			
			const step1obj = {
				'Type of actuator': 'linear actuator',
				'Basic shape': 'triangle',
				'Add a new actuator': function() { controlType = 'Add a new actuator' },
				'Remove an actuator': function() { controlType = 'Remove an actuator' },
				'Rotate the bending direction by 90 degrees': function() { controlType = 'Rotate the bending direction by 90 degrees' },
				'Load mesh': function() { controlType = 'Load mesh' }
			}
						
			const step2obj = {
				// 'Select actuators to create an air channel': function() {selectActuators()},
				'Airchannel 1': function() {
					controlType = "Airchannel 1"
					changeFlag = 1
					buttons.forEach((button,i)=>{
						var num = i+1+''
						button.domElement.classList.add( 'control-inactive'+num);
					})
					buttons[0].domElement.classList.remove( 'control-inactive1' );
				},
				'Airchannel 2': function() {
					controlType = "Airchannel 2"
					changeFlag = 1
					buttons.forEach((button,i)=>{
						var num = i+1+''
						button.domElement.classList.add( 'control-inactive' +num);
					})
					buttons[1].domElement.classList.remove( 'control-inactive2' );
				},
				//按钮添加分组
				'Finish' : function(){//完成分组按钮此时生成第三步界面
					controlType = "step2finish"	
					// button_f.disable()
					buttons.forEach((button,i)=>{
						var num = i+1+''
						button.domElement.classList.add( 'control-inactive'+num );
					})
					e1.destroy()
					e2.destroy()
					e3.destroy()
					e4.destroy()
					e5.destroy()
					e6.destroy()
					e7.destroy()		
					e1 = step3.add( step3obj, 'Choose an air channel', airChannels ).listen().onChange(showAirchannel)
					e2 = step3.add( step3obj, 'Actuation method', ['Deflation', 'Inflation'] ).listen().onChange()
					e3 = step3.add( step3obj, 'Start time (s)', 0, 1, 0.1 ).listen()
					e4 = step3.add( step3obj, 'End time (s)', 1, 5, 0.1 ).listen()
					e5 = step3.add( step3obj, 'Add to sequence motion' )
					e6 = step3.add( step3obj, 'Preview motion' ).listen().onChange( previewMotion )
					e7 = step3.add( step3obj, 'Add loop control' ).listen().onChange()		
					step3.open()
					step3.show()
				},
				'Add new air channel' : function(){//空气分组
					button_f.enable()
					var num = 0
					for (var i in airChannels){
						num++
					}
					// console.log(num)
					var str = num + ''
					
					step2obj["Airchannel "+ str] = function(){
						controlType = "Airchannel "+ str
						changeFlag = 1
						buttons.forEach((button,i)=>{
							var tmp = i+1+''
							var tmp2 = num +''
							button.domElement.classList.add( 'control-inactive'+tmp );
						})
							buttons[num-1].domElement.classList.remove( 'control-inactive'+num );
						}
					
					const button = step2.add( step2obj, "Airchannel "+ str )
					buttons.push(button)
					if(inGroupmode(controlType)){
						var a = parseInt(controlType.substr(-1))-1
						var tmp2 = a+1 + ''
						buttons.forEach((button,i)=>{
							var tmp = i+1+''
							button.domElement.classList.add( 'control-inactive'+tmp );
					})
						buttons[a].domElement.classList.remove( 'control-inactive'+tmp2 );
					}
					airChannels.push("Airchannel "+ str)
					actuationMethods.push('Deflation')
					startTimes.push(0)
					endTimes.push(1)
					moved.push(0)


					// colors.push(color16())
					step3.hide()
					// console.log(airchannel)	
				},
			}

			const step3obj = {
				'Choose an air channel': '-----',
				'Actuation method': 'Deflation',
				'Start time (s)': 0.5,
				'End time (s)': 3.0,
				'Add to sequence motion': function() {
					let airNum = e1.getValue().substr(-1)
					// console.log(e1.getValue())
					if(airNum-''>=0&&airNum-''<=9){
						if(e3.getValue()< e4.getValue()){
							actuationMethods[airNum] = e2.getValue()
							startTimes[airNum] = e3.getValue()
							endTimes[airNum] = e4.getValue()
							if( e4.getValue()>maxEnd){
								maxEnd =  e4.getValue()
							}
						}
						else{
							alert("Time error")
						}
					}
					else{
						alert("Airchannel error")
					}
					console.log("success add")
					// console.log(e3.getValue())
					// console.log(e4.getValue())
					// console.log(e7.getValue())
				},
				'Preview motion': false,
				'Add loop control': false
			}
			
			const step4obj = {
				'Generate control code': function() {}
			}
			
			let INTERSECTED = 0

			var step1 = gui.addFolder( 'Step 1: Create a Shape' )
			var step2 = gui.addFolder( 'Step 2: Group Actuators' )
			
			step2.add( step2obj, 'Add new air channel' )
			const button_f = step2.add( step2obj, 'Finish' )
			const button1 = step2.add( step2obj, 'Airchannel 1' )
			const button2 = step2.add( step2obj, 'Airchannel 2' )
			buttons.push(button1)
			buttons.push(button2)
			step2.open()

			var step3 = gui.addFolder( 'Step 3: Add Actuation & Preview Motion' )
			let e1 = step3.add( step3obj, 'Choose an air channel', airChannels )
			let e2 = step3.add( step3obj, 'Actuation method', ['Deflation', 'Inflation'] )
			let e3 = step3.add( step3obj, 'Start time (s)', 0, 1, 0.1 )
			let e4 = step3.add( step3obj, 'End time (s)', 1, 5, 0.1 )
			let e5 = step3.add( step3obj, 'Add to sequence motion' )
			let e6 = step3.add( step3obj, 'Preview motion' )
			let e7 = step3.add( step3obj, 'Add loop control' )		
			var step4 = gui.addFolder( 'Step 4: Assemble & Generate Control Code' )
			step3.hide()
			step4.hide()
			

			initThree()
			initCannon()
			
			initializeDefaultActuators()
			animate()
			
			initGUI()

			function stopActuators(group){//stop motion not finished
				
				console.log("stopActuators")
				moved[group]=0
			}
			function motionActuators(group) {//start motion  which air channel to move
			
				// parameters for linear actuator
				var tmp = group+''
				var str = 'Airchannel '+ tmp
				//air channel group
				// console.log(str)
				const foldingVelocity = Math.PI / 2.0

				// parameters for bending actuator
				const hingeGroup1 = []
				const hingeGroup2 = []
				const unitNumber = 6
				const unitHingeNum = 16
				
				for ( let i = 0; i < unitNumber; i++ ) {
					hingeGroup1.push( i*unitHingeNum+1, i*unitHingeNum+2, i*unitHingeNum+3, i*unitHingeNum+5, i*unitHingeNum+6, i*unitHingeNum+7 )
					hingeGroup2.push( i*unitHingeNum+0, i*unitHingeNum+4, i*unitHingeNum+8, i*unitHingeNum+9, i*unitHingeNum+10, i*unitHingeNum+11 )
					if ( i < unitNumber - 1 ) {
						hingeGroup1.push( i*unitHingeNum+12, i*unitHingeNum+13, i*unitHingeNum+14, i*unitHingeNum+15 )
					}
				}

				// Assign different stiffness, relaxation to two groups of hinge constraints
				const stiffness_1 = 1e6
				const relaxation_1 = 0.5
				const stiffness_2 = 1e10
				const relaxation_2 = 0.8
				const timeStep = 1/60
				const initialHingeVelocity_1 = -Math.PI / 0.55
				const initialHingeVelocity_2 = Math.PI / 0.3
				
				tubeInfoList.forEach((tube, i) => {
					if(tube.tubeVisual.name==str){
						if(tube.tubeType == 0){
							tube.hingeConstraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(foldingVelocity))
						}
						if(tube.tubeType == 1){
							tube.hingeConstraints.forEach( (hingeConstraint, index) => {
								if ( hingeGroup1.includes(index) ) {
									hingeConstraint.equations.forEach( function( equation ) {
										equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
									})
									hingeConstraint.enableMotor()
									hingeConstraint.setMotorSpeed( initialHingeVelocity_1 )
								}
								
								if ( hingeGroup2.includes(index) ) {
									hingeConstraint.equations.forEach( function( equation ) {
										equation.setSpookParams( stiffness_2, relaxation_2, timeStep )
									})
									hingeConstraint.enableMotor()
									hingeConstraint.setMotorSpeed( initialHingeVelocity_2 )
								}
							})
						}
					}
				})
				
				moved[group] = 1 
			}

			function animate() {
				requestAnimationFrame( animate )
				
				if ( controlType == 'Add a new actuator' && transControl.mode == 'rotate' ) {


					const euler = new THREE.Euler()
					const rotation = euler.setFromQuaternion( refBoxMesh.quaternion )
					const radians_x = rotation.x > 0 ? rotation.x : (2 * Math.PI) + rotation.x
					const deg_x = THREE.MathUtils.radToDeg(radians_x)
					const radians_y = rotation.y > 0 ? rotation.y : (2 * Math.PI) + rotation.y
					const deg_y = THREE.MathUtils.radToDeg(radians_y)
					const radians_z = rotation.z > 0 ? rotation.z : (2 * Math.PI) + rotation.z
					const deg_z = THREE.MathUtils.radToDeg(radians_z)
					
					console.log(deg_x)
					console.log(deg_y)
					console.log(deg_z)

					if ( Math.abs(deg_x - last_deg_x) > 14 || Math.abs(deg_y - last_deg_y) > 14 || Math.abs(deg_z - last_deg_z) > 14) {
						adjustActuatorPosition( refBoxMesh.quaternion )
					}
					last_deg_x = deg_x
					last_deg_y = deg_y
					last_deg_z = deg_z
				}
				//highlight
				if(controlType == "step2finish"){
					tubeInfoList.forEach((object)=>{
						if(object.tubeVisual.name){
							var a = parseInt(object.tubeVisual.name.substr(-1))
							object.tubeVisual.children.forEach( (mesh) => {
								mesh.material.emissive.setHex(colors[a]);
								// console.log(object.children)
							})
						}
					})
				}

				
				if(controlType == 'Motion start'&&count<=maxEnd*100){
								
					for(let i = 1; i<=startTimes.length;i++){
						//starting motion
						//遍历startTime数组判断是否到了开始运动的时间
						if(count==startTimes[i]*100){
							if(moved[i]==0){
								motionActuators(i)
							}			
						}
						//遍历结束时间
						if(count==endTimes[i]*100){
							if(moved[i]==1){
								stopActuators(i)
							}
							
						}
					}					
				}

				//restart clock
				if(step3obj["Add loop control"]==true&&count==maxEnd*100){
						count=0
				}
			
				// Step the physical simulation forward
				world.fixedStep()
				
				// update the position and orientation of the mesh to match the CannonBody
				// for ( let i = 0; i < bodies.length; i++ ) {
				// 	const body = bodies[i]
				// 	const visual = visuals[i]
				// 	visual.position.copy( bodies[i].position )
        		// 	visual.quaternion.copy( bodies[i].quaternion )
				// }
				for ( let i = 0; i < tubeInfoList.length; i++ ) {
					for ( let j = 0; j < tubeInfoList[i].hingeBodies.length; j++ ) {
						const body = tubeInfoList[i].hingeBodies[j]
						const visual = tubeInfoList[i].tubeVisual.children[j]
						visual.position.copy( body.position )
						visual.quaternion.copy( body.quaternion )
					}
				}
				
				for ( let i = 0; i < connectorBodies.length; i++ ) {
					const body = connectorBodies[i]
					const visual = connectorMeshes[i]
					visual.position.copy( body.position )
					visual.quaternion.copy( body.quaternion )
				}
			
				// Stop hinge bodies folding through each other while deflation
				stopFacesFoldThrough()
				
				// Prevent the tube from becoming a flat surface while inflation
				// stopInflation()
				
				// Render three.js objects
				controls.update()
				renderer.render( scene, camera )
			}

			function timeIndicing(){//计时器 100毫秒加一次count
				timeCount = setInterval(function(){
					count++
					
				},100)
			}
			function showAirchannel(value){//airchannel UI data updata
				let tmp = value.substr(-1)
				// console.log(tmp)
				if(tmp-''>=0&&tmp-''<=9){
					step3obj['Actuation method'] = actuationMethods[tmp]
					step3obj['Start time (s)'] = startTimes[tmp]
					step3obj['End time (s)'] = endTimes[tmp]
				}		
			}

			function previewMotion( value ) {
				// Preview motion based on the user defined actuation sequence
				// console.log(value)
				//two motiontype
				if(value==true){	
					controlType = 'Motion start'
					// inflationActuators()
					timeIndicing()//开始计时
				}
				if(value==false){
					controlType = 'Motion stop'					
					clearInterval(timeCount)//重置计时器
					count = 0
				}
				// inflateTube( inflationLinearActuators )
			}

			function inGroupmode(mode){//groupingmode
				var flag = 0
				for (var i in step2obj){
						if(i==mode){
							flag = 1
						}
					}
				return flag
			}
			
			function initGUI() {
				/**
				 * User interface & design workflow
				*/
				
				step1.add( step1obj, 'Type of actuator', [ 'linear actuator', 'bending actuator' ] )
				step1.add( step1obj, 'Basic shape', [ 'trangle', 'rectangle', 'tetrahedron' ] )
				step1.add( step1obj, 'Add a new actuator' )
				step1.add( step1obj, 'Remove an actuator' )
				step1.add( step1obj, 'Rotate the bending direction by 90 degrees')
				// step1.add( step1obj, 'Load mesh', 'Load mesh' )
				step1.open()
				
				step4.add( step4obj, 'Generate control code' )
				step4.open()
			}
			
			// User interactions
			window.addEventListener( 'pointerdown', (event) => {
				/**
				 * Fired when a pointer becomes active state
				 * Cast a ray from where the mouse is pointing to select a connector
				 * Get 3D point from the client x y coordinates
				*/
				const mouse = new THREE.Vector2()
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1
				mouse.y = -(( event.clientY / window.innerHeight ) * 2 - 1)
				
				// Get the picking ray from the point
				const raycaster = new THREE.Raycaster()
				raycaster.setFromCamera( mouse, camera )
				
				let selectedConnectorIndex
				let selectedTubeIndex
				
				// Loop the data lists to get which object is selected by the user
				for ( let i = 0; i < connectorMeshes.length; i++ ) {
					const hits = raycaster.intersectObject( connectorMeshes[i] )
					// Get the closest hit object
					if ( hits.length > 0 ) {
						// const object = hits[0].object
						selectedConnectorIndex = i
					}
				}
				
				// Get selected tube by the user
				for ( let i = 0; i < tubeInfoList.length; i++ ) {
					const hits = raycaster.intersectObject( tubeInfoList[i].tubeVisual )
					if ( hits.length > 0 ) {
						selectedTubeIndex = i
					}
				}

				if (inGroupmode(controlType)){
					
					if(tubeInfoList[selectedTubeIndex]){
						changeFlag = 1
						// var a = parseInt(controlType.substr(-1))
						if(tubeInfoList[selectedTubeIndex].tubeVisual.name != controlType){
							tubeInfoList[selectedTubeIndex].tubeVisual.name = controlType
						}
						else if(tubeInfoList[selectedTubeIndex].tubeVisual.name == controlType){
							tubeInfoList[selectedTubeIndex].tubeVisual.name=''
						}	
					}
				}

				// Divide mouse selections based on the variable controlType
				if ( controlType == 'Add a new actuator' ) {
					if(connectorMeshes[selectedConnectorIndex]){
						addNewActuator( selectedConnectorIndex )
					}
				}
				
				if ( controlType == 'Remove an actuator' ) {
					if(tubeInfoList[selectedTubeIndex]){
						removeActuator( selectedTubeIndex )
					}	
				}
				
				if ( controlType == 'Rotate the bending direction by 90 degrees' ) {
					if(tubeInfoList[selectedTubeIndex]){
						rotateBendingActuator( selectedTubeIndex )
					}
				}
				
				// Clear the last selection
				selectedConnectorIndex = undefined
				selectedTubeIndex = undefined
			})
			
			// User interface functions
			function addNewActuator( selectedConnectorIndex ) {
				if ( selectedConnectorIndex != undefined ) {
					if ( step1obj['Type of actuator'] == 'linear actuator' ) {
						var tubeType = 0
					} else if ( step1obj['Type of actuator'] == 'bending actuator' ) {
						var tubeType = 1
					}
					console.log("Add a " + step1obj['Type of actuator'])
					
					// Transform the new added actuator
					transControl.detach()
					transControl = new TransformControls( camera, renderer.domElement )
					transControl.setSize( 0.5 )
					transControl.attach( connectorMeshes[ selectedConnectorIndex ] )
					scene.add( transControl )
					
					const actuatorNum = tubeInfoList.length
					console.log(actuatorNum)
					transControl.addEventListener( 'mouseDown', function() {
						// Ensure that only one actuator is added based on selected connector and axis
						if ( transControl.axis == 'X' ) {
							var tube = addMiuraTube( tubeType, selectedConnectorIndex, axis[0], angle[0] )
							tubeInfoList.push( tube )
						} else if ( transControl.axis == 'Y' ) {
							var tube = addMiuraTube( tubeType, selectedConnectorIndex, axis[2], angle[5] )
							tubeInfoList.push( tube )
						} else if ( transControl.axis == 'Z' ) {
							var tube = addMiuraTube( tubeType, selectedConnectorIndex, axis[1], -angle[5] )
							tubeInfoList.push( tube )
						}
						
						if ( tubeInfoList.length - actuatorNum == 1 ) {
							transControl.detach()
							
							transControl = new TransformControls( camera, renderer.domElement )
							transControl.addEventListener( 'change', function() { renderer.render( scene, camera ) } )
							transControl.addEventListener( 'dragging-changed', function ( event ) {
								controls.enabled = ! event.value
							} )
							console.log(connectorMeshes[ selectedConnectorIndex ].position)
							refBoxMesh.position.copy( connectorMeshes[ selectedConnectorIndex ].position )
							scene.add( refBoxMesh )
							// transControl.attach( tubeInfoList[ tubeInfoList.length - 1 ].tubeVisual )
							// transControl.position.copy( connectorMeshes[ selectedConnectorIndex ].position )
							transControl.attach( refBoxMesh )
							transControl.setSize( 0.5 )
							scene.add( transControl )
							transControl.setMode( 'rotate' )
							transControl.setRotationSnap( 15 * Math.PI / 180 ) // set the rotation snap to 15 deg
						}
					} )
				} else {
					// console.log('No connector is selected for adding new actuator')
				}
			}
			
			function adjustActuatorPosition( quaternion ) {
				// if ( Math.abs(radians_x - 2*Math.PI) > 0.001 || Math.abs(radians_y - 2*Math.PI) > 0.001 || Math.abs(radians_z - 2*Math.PI) > 0.001 ) {
				// 	tubeInfoList[ tubeInfoList.length - 1 ].tubeVisual.quaternion.copy(refBoxMesh.quaternion)
				// }
				
				const tube = tubeInfoList[ tubeInfoList.length - 1 ].tubeVisual
				
				tube.parent.localToWorld(tube.position)
				
				const tubeCenter = new THREE.Vector3( tubeInfoList[ tubeInfoList.length - 1 ].position.x, tubeInfoList[ tubeInfoList.length - 1 ].position.y, tubeInfoList[ tubeInfoList.length - 1 ].position.z )
				const unitVec = new THREE.Vector3( tubeInfoList[ tubeInfoList.length - 1 ].unitVec.x, tubeInfoList[ tubeInfoList.length - 1 ].unitVec.y, tubeInfoList[ tubeInfoList.length - 1 ].unitVec.z )
				const pivot = tubeCenter.sub( unitVec )
				console.log( pivot )
				tube.position.sub( pivot )
				// tube.quaternion.copy(refBoxMesh.quaternion)
				tube.position.applyQuaternion(quaternion)
				tube.position.add(pivot)
				tube.parent.worldToLocal( tube.position )
				tube.applyQuaternion(quaternion)
			}
			
			function removeActuator( selectedTubeIndex ) {
				if ( selectedTubeIndex != undefined ) {
					// Remove the physical cannon.js body
					world.removeBody( tubeInfoList[ selectedTubeIndex ].hingeBodies )
					world.removeConstraint( tubeInfoList[ selectedTubeIndex ].hingeConstraints )
					
					// Update the index of deflationActuators
					const index = deflationActuators.indexOf( selectedTubeIndex )
					if ( index > -1 ) {
						deflationActuators.splice( index, 1 )
						for ( let i = index; i < deflationActuators.length; i++ ) {
							deflationActuators[i] = deflationActuators[i] - 1
						}
					} else {
						for ( let i = 0; i < deflationActuators.length; i++ ) {
							if ( deflationActuators[i] > selectedTubeIndex ) {
								deflationActuators[i] = deflationActuators[i] - 1
							}
						}
					}
					
					// Remove the three.js object from the scene
					scene.remove( tubeInfoList[ selectedTubeIndex ].tubeVisual )
					
					// Remove the item from the data array
					tubeInfoList.splice( selectedTubeIndex, 1 )
					
					// Remove the not used connector simultaneously
					var inuse = false
					for ( let i = 0; i < connectorMeshes.length; i++ ) {
						const aabb = new THREE.Box3()
						aabb.setFromObject( connectorMeshes[i] )
						const center = new THREE.Vector3()
						aabb.getCenter( center )
						// Check if there is adjacent tube by distance
						for ( let j = 0; j < tubeInfoList.length; j++ ) {
							const aabbTube = new THREE.Box3()
							aabbTube.setFromObject( tubeInfoList[j].tubeVisual )
							const centerTube = new THREE.Vector3()
							aabbTube.getCenter( centerTube )
							
							const dis = center.distanceTo( centerTube )
							if ( Math.abs( dis - 93 ) < 1 ) {
								inuse = true
							}
						}
						// Remove the connector in three.js and cannon.js
						if ( inuse == false ) {
							scene.remove( connectorMeshes[i] )
							connectorMeshes.splice( i, 1 )
							world.removeBody( connectorBodies[i] )
							connectorBodies.splice( i, 1 )
						}
						inuse = false
					}
				}
			}
			
			function rotateBendingActuator( selectedTubeIndex ) {
				if ( selectedTubeIndex != undefined ) {
					if ( tubeInfoList[ selectedTubeIndex ].tubeType == 1 ) {
						console.log( 'Rotate the bending direction by 90 degrees' )
						// Need the unitVec of the tube for rotation
					}
				}
			}
						
			// Basic functions
			function initializeDefaultActuators() {
				/**
				 * Initialize a default connector in the physical world and visualize it in the scene
				 * Get parameters from the user interface
				 * Let users manipulate tubes in the scene by selecting the connector and pre-defined angles
				 * TubeType is 0 => linear actuator, TubeType is 1 => bending actuator
				 * Axis index: x=>(1,0,0), y=>(0,1,0), z(0,0,1)
				 * Angle index: 0=0, 1=>30, 2=>45, 3=>60, 4=>75, 5=>90, 6=>120, 7=>135, 8=>150, 9=>165, 10=>180
				*/
				const defaultConnector = initDefaultConnector()
				connectorBodies.push( defaultConnector )
				bodyToMesh( defaultConnector ).forEach( (mesh) => {
					scene.add( mesh )
					connectorMeshes.push( mesh )
				})
				
				var tubeType = 1
				var connectorIndex = 0
				var tube = addMiuraTube( tubeType, connectorIndex, axis[1], angle[2] )
				tubeInfoList.push( tube )
				var index = 0
				deflationActuators.push( index )
				
				var tubeType = 1
				var connectorIndex = 0
				var tube = addMiuraTube( tubeType, connectorIndex, axis[1], -angle[2] )
				tubeInfoList.push( tube )
				var index = 1
				deflationActuators.push( index )
				
				var tubeType = 1
				var connectorIndex = 0
				var tube = addMiuraTube( tubeType, connectorIndex, axis[1], angle[7] )
				tubeInfoList.push( tube )
				var index = 2
				deflationActuators.push( index )
				
				var tubeType = 1
				var connectorIndex = 0
				var tube = addMiuraTube( tubeType, connectorIndex, axis[1], -angle[7] )
				tubeInfoList.push( tube )
				var index = 3
				deflationActuators.push( index )
				
				var tubeType = 0
				var connectorIndex = 1
				var tube = addMiuraTube( tubeType, connectorIndex, axis[2], angle[5] )
				tubeInfoList.push( tube )
				var index = 4
				deflationActuators.push( index )
				
				var tubeType = 0
				var connectorIndex = 2
				var tube = addMiuraTube( tubeType, connectorIndex, axis[2], angle[5] )
				tubeInfoList.push( tube )
				
				var tubeType = 0
				var connectorIndex = 3
				var tube = addMiuraTube( tubeType, connectorIndex, axis[2], angle[5] )
				tubeInfoList.push( tube )
				var index = 5
				deflationActuators.push( index )
			}
			
			function addMiuraTube( tubeType, connectorIndex, axis, angle ) {
				/**
				 * Initiate a new physical tube with customized position and quaternion
				 * Treat a new miura-ori tube as a three.js group and render
				 * Automatically add connector bodies to the tube
				 * TubeType is 0 => linear miura-ori tube; TubeType is 1 => bending miura-ori tube
				*/
				
				// Calculate position and quaternion according to the connectorIndex, axis and angleIndex
				const quaternion = new CANNON.Quaternion()
				quaternion.setFromAxisAngle( axis, angle )

				// Copy pivot connector position
				const position = new CANNON.Vec3().copy( connectorBodies[connectorIndex].position )
				
				const intervalDistance = 12.954878  // half width of the Miura-ori tube unit
				const sphereRadius = 15.0  // connector bounding sphere radius
				const unitVec = new CANNON.Vec3( sphereRadius + intervalDistance, 0, 0 )
				quaternion.vmult( unitVec, unitVec )
				position.vadd( unitVec, position )
				
				// Render tube physical bodies to the view based on customized position and quaternion
				if ( tubeType == 0 ) {
					// straight miura-ori tube
					var tubeInfo = initDefaultMiuraTube( position, quaternion )
				} else if ( tubeType == 1 ) {
					// bending miura-ori tube
					var tubeInfo = initBendingMiuraTube( position, quaternion )
				}
				
				const hingeBodies = tubeInfo.hingeBodiesArray
				const hingeConstraints = tubeInfo.constraints
				
				const tubeVisual = new THREE.Group()
				hingeBodies.forEach( (body, i) => {
					const meshes = bodyToMesh( body )
					meshes.forEach( (mesh) => { tubeVisual.add( mesh ) } )
				})
				
				scene.add( tubeVisual )
				
				// Automatically add new connector body to the scene when adding a new tube
				const newConnector = attachConnector( connectorIndex, hingeBodies, unitVec )
				if ( newConnector != undefined ) {
					connectorBodies.push( newConnector )
					bodyToMesh( newConnector ).forEach( (mesh) => {
						scene.add( mesh )
						connectorMeshes.push( mesh )
					})
				}
				
				return {tubeType, tubeVisual, hingeBodies, hingeConstraints, unitVec, position, quaternion}
			}
			
			function initDefaultConnector() {
				/**
				 * Initialize a default connector in the physical world
				*/
				const sphereRadius = 15
				const sphereShape = new CANNON.Sphere(sphereRadius)
				
				const defaultConnector = new CANNON.Body({
					mass: 0.1,
					type: CANNON.Body.DYNAMIC,
					shape: sphereShape,
					position: new CANNON.Vec3(0, -45, 0)
				})
				
				// No collision needed
				defaultConnector.collisionFilterGroup = 0
				defaultConnector.collisionFilterMask = 0
				world.addBody(defaultConnector)
				
				return defaultConnector
			}
			
			function attachConnector( connectorIndex, hingeBodies, unitVec ) {
				/**
				 * Add lock constraints between the selected connector and hinge bodies
				 * Attach a new connector to the end of the tube
				*/
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[0] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[2] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[4] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[6] ))
				
				// Pre-defined tube bounding box dimensions: length => 155.458538, width => 37.288780, height => 17.527490
				const bBoxLength = 155.458538
				const bBoxWidth = 37.288780
				const bBoxHeight = 17.527490
				
				const sphereRadius = 15
				const sphereShape = new CANNON.Sphere(sphereRadius)
				// const boxShape = new CANNON.Box(new CANNON.Vec3(10,10,10))
				
				const newPos = unitVec.unit()
				const distance = bBoxLength + sphereRadius * 2
				newPos.scale( distance, newPos )
				newPos.vadd( connectorBodies[connectorIndex].position, newPos )
				
				// Set a flag: True => Add a new connector; Flase => Do not add
				let flag = true
				
				// Check if there is a existing connector in the new position
				for ( let i = 0; i < connectorBodies.length; i++ ) {
					const vecEqual = newPos.almostEquals( connectorBodies[i].position )
					if ( vecEqual == true ) {
						flag = false
						
						// Add lock constraints between the exsiting connector and hinge bodies
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-1] ))
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-3] ))
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-5] ))
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-7] ))
					}
				}
				
				if ( flag == false ) {
					return undefined
				} else {
					// Attach a new connector to the end of the tube
					const newConnector = new CANNON.Body({
						mass: 0.1,
						type: CANNON.Body.DYNAMIC,
						shape: sphereShape,
						position: newPos
					})
					newConnector.collisionFilterGroup = 0
					newConnector.collisionFilterMask = 0
					world.addBody(newConnector)
					
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-1] ))
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-3] ))
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-5] ))
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-7] ))
					
					return newConnector
				}
			}
			
			function initDefaultMiuraTube( position, quaternion ) {
				/**
				 * Store face coordinates from the Grasshopper file with 0.65 folding ratio
				 * Store vertices and indices for the body and geometry of the miura-ori tube
				 * Initiate the physical miura-ori tube with Trimesh shape
				 * Specify hinge constraints with axis and pivot point
				*/				
				const faceVertices_1 = new Float32Array([
					0, 0, 0,
					0, 12.173610, 8.763745,
					-12.95488, -0.768048, 8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_2 = new Float32Array([
					0, 0, 0,
					12.95488, -12.941658, 0,
					12.954878, -0.768048, 8.763745,
					0, 12.173610, 8.763745
				])
				const faceVertices_3 = new Float32Array([
					0, 12.173610, 8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, 8.763745
				])
				const faceVertices_4 = new Float32Array([
					0, 12.173610, 8.763745,
					12.954878, -0.768048, 8.763745,
					12.954878, 11.405561, 0,
					0, 24.347219, 0
				])
				const faceVertices_5 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					-12.954878, -0.768048, -8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_6 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					12.954878, -0.768048, -8.763745,
					12.954878, -12.941658, 0
				])
				const faceVertices_7 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, -8.763745
				])
				const faceVertices_8 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					12.954878, 11.405561, 0,
					12.954878, -0.768048, -8.763745
				])
				
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				// Number of faces in a miura-ori unit
				const unitNumber = 6	// a miura-ori tube has 6 units
				const unitFacesNum = 8  // a unit has 8 quadrilaterals
				let hingeBodiesArray = new Array( unitNumber * unitFacesNum )
				const mass = 0.1
				
				// Set the quaternion of the intervalVec
				const intervalDistance = 12.954878 * 2
				const intervalVec = new CANNON.Vec3( intervalDistance, 0, 0 )
				const intervalQuat = new CANNON.Quaternion().copy( quaternion )	// Rotate the intervalVec
				intervalQuat.vmult( intervalVec, intervalVec )
				
				// Whether to add hinge constraints (for test)
				const useHingeConstraints = true
				let constraints = []
				
				// Initiatize hinge bodies with shape, position, and quaternion
				for ( let i = 0; i < unitNumber; i++ ) {
                    hingeBodiesArray[ i*unitFacesNum ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum ] )
                    
					hingeBodiesArray[ i*unitFacesNum+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+1 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+2 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+3 ] )

					hingeBodiesArray[ i*unitFacesNum+4 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_5, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+4 ] )
					
					hingeBodiesArray[ i*unitFacesNum+5 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_6, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+5 ] )

					hingeBodiesArray[ i*unitFacesNum+6 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_7, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+6 ] )
					
					hingeBodiesArray[ i*unitFacesNum+7 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_8, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+7 ] )
                }
				
				// Specify a list of hinge constraints
				if (useHingeConstraints) {
					for ( let i = 0; i < unitNumber; i++ ) {
						const axis1 = new CANNON.Vec3( 0, 0.811574, 0.58425 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+1 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis1,	
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis1,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis2 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+2 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis2,
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis2,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis3 = new CANNON.Vec3( 0.707468, -0.706746, 0 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis3,
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis3,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis4 = new CANNON.Vec3( 0, -0.811574, 0.58425 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis4,	
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis4,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis5 = new CANNON.Vec3( 0, -0.811574, 0.58425 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis5,	
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis5,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis6 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis6,
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis6,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis7 = new CANNON.Vec3( -0.707468, 0.706746, 0 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis7,
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis7,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis8 = new CANNON.Vec3( 0, 0.811574, 0.58425 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+6 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis8,	
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis8,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis9 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+4 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis9,
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis9,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis10 = new CANNON.Vec3( 0.707468, -0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis10,
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis10,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis11 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisA: axis11,
								pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisB: axis11,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis12 = new CANNON.Vec3( -0.707468, 0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisA: axis12,
								pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisB: axis12,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						// Specify hinge constraints to connect multiple units
						if ( i < unitNumber -1 ) {
							const axis13 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // mountain hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ (i+1)*unitFacesNum ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
									axisA: axis13,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
									axisB: axis13,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis14 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // vally hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ (i+1)*unitFacesNum+2 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
									axisA: axis14,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
									axisB: axis14,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis15 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // mountain hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ (i+1)*unitFacesNum+4 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
									axisA: axis15,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
									axisB: axis15,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis16 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // vally hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+7], hingeBodiesArray[ (i+1)*unitFacesNum+6 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
									axisA: axis16,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
									axisB: axis16,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
						}
					}
				}

				const stiffness = 1e10
				const relaxation = 0.5
				const timeStep = 1/60
				
				// Add the constraints to the world and enable hinge motor, each tube has 92 hinge constraints
				constraints.forEach( function( constraint ) {
					constraint.equations.forEach(function( equation ) {
						// set greater stiffness on the hinge
						equation.setSpookParams( stiffness, relaxation, timeStep )
					})
					
					constraint.enableMotor()
					constraint.setMotorSpeed( initialHingeVelocity )
					world.addConstraint( constraint )
				})
				
				return {hingeBodiesArray, constraints}
			}
			
			function initBendingMiuraTube( position, quaternion ) {
				// Initiate a physical miura-ori tube with bending simulation
				const faceVertices_1 = new Float32Array([
					0, 0, 0,
					0, 12.173610, 8.763745,
					-12.95488, -0.768048, 8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_2 = new Float32Array([
					0, 0, 0,
					12.95488, -12.941658, 0,
					12.954878, -0.768048, 8.763745,
					0, 12.173610, 8.763745
				])
				const faceVertices_3 = new Float32Array([
					0, 12.173610, 8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, 8.763745
				])
				const faceVertices_4 = new Float32Array([
					0, 12.173610, 8.763745,
					12.954878, -0.768048, 8.763745,
					12.954878, 11.405561, 0,
					0, 24.347219, 0
				])
				const faceVertices_5 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					-12.954878, -0.768048, -8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_6 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					12.954878, -0.768048, -8.763745,
					12.954878, -12.941658, 0
				])
				const faceVertices_7 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, -8.763745
				])
				const faceVertices_8 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					12.954878, 11.405561, 0,
					12.954878, -0.768048, -8.763745
				])
				
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				// Number of faces in a miura-ori unit
				const unitNumber = 6	// a miura-ori tube has 6 units
				const unitFacesNum = 8  // a unit has 8 quadrilaterals
				let hingeBodiesArray = new Array( unitNumber * unitFacesNum )
				const mass = 0.1
				
				// Set the quaternion of the intervalVec
				const intervalDistance = 12.954878 * 2
				const intervalVec = new CANNON.Vec3( intervalDistance, 0, 0 )
				const intervalQuat = new CANNON.Quaternion().copy( quaternion )	// Rotate the intervalVec
				intervalQuat.vmult( intervalVec, intervalVec )
				
				// Whether to add hinge constraints (for test)
				const useHingeConstraints = true
				let constraints = []
				
				// Initiatize hinge bodies with shape, position, and quaternion
				for ( let i = 0; i < unitNumber; i++ ) {
                    hingeBodiesArray[ i*unitFacesNum ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum ] )
                    
					hingeBodiesArray[ i*unitFacesNum+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+1 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+2 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+3 ] )

					hingeBodiesArray[ i*unitFacesNum+4 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_5, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+4 ] )
					
					hingeBodiesArray[ i*unitFacesNum+5 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_6, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+5 ] )

					hingeBodiesArray[ i*unitFacesNum+6 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_7, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+6 ] )
					
					hingeBodiesArray[ i*unitFacesNum+7 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_8, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+7 ] )
                }
				
				// Specify a list of hinge constraints
				if (useHingeConstraints) {
					for ( let i = 0; i < unitNumber; i++ ) {
						const axis1 = new CANNON.Vec3( 0, 0.811574, 0.58425 )
						const hinge1 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+1 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis1,	
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis1,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge1 )
						constraints.push( hinge1 )
						
						const axis2 = new CANNON.Vec3( 0.707468, 0.706746, 0 )
						const hinge2 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+2 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisA: axis2,
							pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisB: axis2,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge2 )
						constraints.push( hinge2 )
						
						const axis3 = new CANNON.Vec3( 0.707468, -0.706746, 0 )
						const hinge3 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisA: axis3,
							pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisB: axis3,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge3 )
						constraints.push( hinge3 )
						
						const axis4 = new CANNON.Vec3( 0, -0.811574, 0.58425 )
						const hinge4 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis4,	
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis4,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge4 )
						constraints.push( hinge4 )
						
						const axis5 = new CANNON.Vec3( 0, -0.811574, 0.58425 )
						const hinge5 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis5,	
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis5,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge5 )
						constraints.push( hinge5 )
						
						const axis6 = new CANNON.Vec3( -0.707468, -0.706746, 0 )
						const hinge6 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisA: axis6,
							pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisB: axis6,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge6 )
						constraints.push( hinge6 )
						
						const axis7 = new CANNON.Vec3( -0.707468, 0.706746, 0 )
						const hinge7 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisA: axis7,
							pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisB: axis7,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge7 )
						constraints.push( hinge7 )
						
						const axis8 = new CANNON.Vec3( 0, 0.811574, 0.58425 )
						const hinge8 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+6 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisA: axis8,	
							pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisB: axis8,	
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge8 )
						constraints.push( hinge8 )
						
						const axis9 = new CANNON.Vec3( 0.707468, 0.706746, 0 )
						const hinge9 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+4 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis9,
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis9,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge9 )
						constraints.push( hinge9 )
						
						const axis10 = new CANNON.Vec3( 0.707468, -0.706746, 0 )
						const hinge10 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis10,
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis10,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge10 )
						constraints.push( hinge10 )
						
						const axis11 = new CANNON.Vec3( -0.707468, -0.706746, 0 )
						const hinge11 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
							pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisA: axis11,
							pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisB: axis11,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge11 )
						constraints.push( hinge11 )
						
						const axis12 = new CANNON.Vec3( -0.707468, 0.706746, 0 )
						const hinge12 =	new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
							pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisA: axis12,
							pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisB: axis12,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge12 )
						constraints.push( hinge12 )
						
						// Specify hinge constraints to connect multiple units
						if ( i < unitNumber - 1 ) {
							const axis13 = new CANNON.Vec3( 0, -0.811574, -0.58425 )
							const hinge13 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ (i+1)*unitFacesNum ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
								axisA: axis13,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
								axisB: axis13,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							world.addConstraint( hinge13 )
							constraints.push( hinge13 )
							
							const axis14 = new CANNON.Vec3( 0, 0.811574, -0.58425 )
							const hinge14 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ (i+1)*unitFacesNum+2 ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
								axisA: axis14,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
								axisB: axis14,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							world.addConstraint( hinge14 )
							constraints.push( hinge14 )
							
							const axis15 = new CANNON.Vec3( 0, 0.811574, -0.58425 )
							const hinge15 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ (i+1)*unitFacesNum+4 ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
								axisA: axis15,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
								axisB: axis15,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							world.addConstraint( hinge15 )
							constraints.push( hinge15 )
							
							const axis16 = new CANNON.Vec3( 0, -0.811574, -0.58425 )
							const hinge16 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+7], hingeBodiesArray[ (i+1)*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
								axisA: axis16,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
								axisB: axis16,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							world.addConstraint( hinge16 )
							constraints.push( hinge16 )
						}
					}
				}
				return {hingeBodiesArray, constraints}
			}
			
			function initFlatMiuraTube() {
				/**
				 * Note that this function folds the tube from a flat surface
				 * Store vertices and indices for the geometry of miura-ori tube
				 * Initiate the physical miura-ori tube with Trimesh shape
				 * Specify hinge constraints with axis and pivot point
				*/
				const faceVertices_1 = new Float32Array([
					0, -15, 0,
					0, 0, 0, 
					-15.0, -10.503123, 0,
					-15.0, -25.503113, 0
				])
				const faceVertices_2 = new Float32Array([
					0, -15, 0,	
					15.0, -25.503113, 0,
					15.0, -10.503123, 0,
					0, 0, 0
				])
				const faceVertices_3 = new Float32Array([
					0, 0, 0,
					0, 15.0, 0,
					-15.0, 4.496877, 0,
					-15.0, -10.503123, 0
				])
				const faceVertices_4 = new Float32Array([
					0, 0, 0,
					15.0, -10.503123, 0,
					15.0, 4.496877, 0,
					0, 15.0, 0
				])
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				const mass = 10
				const intervalDistance = 15.0 * 2
				
				// Define hinge bodies
				for (let i = 0; i < unitNumber; i++) {
                    hingeBodiesArray[ i*4 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4 ] )
                    
					hingeBodiesArray[ i*4+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+1 ] )
                    
					hingeBodiesArray[ i*4+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+2 ] )
                    
					hingeBodiesArray[ i*4+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+3 ] )
                }
				
				// Specify a list of constraints
				for (let i = 0; i < unitNumber; i++) {
					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4 ], hingeBodiesArray[ i*4+1 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0, 1, 0), // vally hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0, 1, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4 ], hingeBodiesArray[ i*4+2 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0.819252, 0.573576, 0), // mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0.819252, 0.573576, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4+1 ], hingeBodiesArray[ i*4+3 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0.819252, -0.573576, 0),	// mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0.819252, -0.573576, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4+2 ], hingeBodiesArray[ i*4+3 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0,-1,0),	// mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0,-1,0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)
					
					if ( i < unitNumber -1 ) {
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*4+1 ], hingeBodiesArray[ (i+1)*4 ], {
								pivotA: new CANNON.Vec3(15, 0, 0),
								axisA: new CANNON.Vec3(0, -1, 0), // mountain hinge
								pivotB: new CANNON.Vec3(-15, 0, 0),
								axisB: new CANNON.Vec3(0, -1, 0),
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*4+3 ], hingeBodiesArray[ (i+1)*4+2 ], {
								pivotA: new CANNON.Vec3(15, 0, 0),
								axisA: new CANNON.Vec3(0, 1, 0), // vally hinge 
								pivotB: new CANNON.Vec3(-15, 0, 0),
								axisB: new CANNON.Vec3(0, 1, 0),
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
					}
				}
				
				const stiffness = 1e10
				const relaxation = 4
				const timeStep = 1/60
				// add the constraints to the world and enable hinge motor
				constraints.forEach( function( constraint ) {
					constraint.equations.forEach(function( equation ) {
						// set greater stiffness on the hinge
						equation.setSpookParams( stiffness, relaxation, timeStep )
					})
					
					constraint.enableMotor()
					constraint.setMotorSpeed( initialHingeVelocity )
					world.addConstraint( constraint )
				})
			}
			
			function initCannon() {
				world = new CANNON.World()
				world.solver.iterations = 20
				world.quatNormalizeFast = true
				
				// Set the gravity vector
				if (useGravity == true) {
					world.gravity.set(0, -9.82, 0)
				}
				
				// Create a static ground
				const groundBody = new CANNON.Body({
					type: CANNON.Body.Static,
					shape: new CANNON.Plane(),
					material: new CANNON.Material('ground')
				})
				
				// Visualization of the plane geometry is defined in initThree()
				groundBody.quaternion.setFromEuler( -Math.PI / 2, 0, 0 )
				groundBody.position.set( 0, -60, 0 )
				world.addBody(groundBody)
			}
			
			function bodyToMesh( body ) {
				/**
				 * Convert cannon bodies to three.js meshes directly
				*/
				if ( !(body instanceof CANNON.Body) ) {
					throw new Error('The argument passed to bodyToMesh() is not a body')
				}
				
				// Materials
				const basicMaterial = new THREE.MeshBasicMaterial( {color: 0x44aa88, side: THREE.DoubleSide, wireframe: false} )
				const phongMaterial = new THREE.MeshPhongMaterial( {color: 0x44aa88, side: THREE.DoubleSide, wireframe: false} )
				const normalMaterial = new THREE.MeshNormalMaterial( {side: THREE.DoubleSide, wireframe: false} )
				const lambertMaterial = new THREE.MeshLambertMaterial( { color: initColor ,side: THREE.DoubleSide,  wireframe: false} )
				const material = lambertMaterial
				// const colors = new Float32Array()
				
				// Get the mesh of body
				const meshes = body.shapes.map( (shape) => {
					switch (shape.type) {
						// check the shape type
						case CANNON.Shape.types.TRIMESH: {
							const verticeNum = shape.indices.length * 3
							const v0 = new CANNON.Vec3()
							const v1 = new CANNON.Vec3()
							const v2 = new CANNON.Vec3()
							
							const geometry = new THREE.BufferGeometry()
							const vertices = new Float32Array( verticeNum )
							const indices = new Uint16Array( shape.indices.length )
							let posNdx = 0
							
							for ( let i = 0; i < shape.indices.length / 3; i++ ) {
								shape.getTriangleVertices( i, v0, v1, v2 )
								
								const positions = [v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z]
								posNdx = posNdx + i * 3 * 3
								vertices.set( positions, posNdx )
								indices.set( [i*3, i*3+1, i*3+2], i * 3 )
							}
							// console.log(vertices)
							// console.log(indices)
							geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3) )
							geometry.setIndex( new THREE.BufferAttribute(indices, 1) )
							
							geometry.computeBoundingSphere()
							geometry.computeVertexNormals()
							
							return new THREE.Mesh( geometry, material )
						}
						
						case CANNON.Shape.types.SPHERE: {
							const geometry = new THREE.SphereGeometry( shape.radius )
							return new THREE.Mesh( geometry, material )
						}
						
						case CANNON.Shape.types.BOX: {
							const geometry = new THREE.BoxGeometry( shape.halfExtents.x * 2, shape.halfExtents.y * 2, shape.halfExtents.z * 2 )
							return new THREE.Mesh( geometry, material )
						}
					}
				})
				
				// In case multiple shapes in one body (compound body)
				meshes.forEach( (mesh, i) => {
					// console.log(mesh)
					mesh.position.copy( body.shapeOffsets[i] )
					mesh.quaternion.copy( body.shapeOrientations[i] )
					mesh.material.emissive.setHex(initColor)
					// Enable shadows on every object
					mesh.receiveShadow = true
    				mesh.castShadow = true
					
					// For function animation()
					bodies.push(body)
					visuals.push(mesh)
				})
				return meshes
			}
			
			function initThree() {
				THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 )
				
				// Renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } )
				renderer.setPixelRatio( window.devicePixelRatio )
				renderer.setSize( window.innerWidth, window.innerHeight )
				renderer.outputEncoding = THREE.sRGBEncoding
				document.body.appendChild( renderer.domElement )
				renderer.shadowMap.enabled = true
    			renderer.shadowMap.type = THREE.PCFSoftShadowMap
				
				renderer.shadowMap.enabled = true
        		renderer.shadowMap.type = THREE.PCFSoftShadowMap
				
				// Camera
				camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 0.01, 1000 )
				camera.position.set( 0, 500, 400 )
				
				// Scene
				scene = new THREE.Scene()
				scene.background = new THREE.Color( 'rgb(240, 240, 240)' )
				
				// Lights
				scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.1 ) )
				const directionalLight = new THREE.DirectionalLight( 0xFFFFFF, 2 )
				directionalLight.position.set( -30, 40, 30 )
				directionalLight.target.position.set( 0, 0, 0 )
				scene.add( directionalLight )
				
				// const floorGeometry = new THREE.PlaneGeometry( 5000, 5000, 100, 100 )
				// floorGeometry.rotateX( -Math.PI / 2 )
				// const floorMaterial = new THREE.MeshLambertMaterial( { color: 0x787878 } )
				// const floor = new THREE.Mesh( floorGeometry, floorMaterial )
				// floor.position.set( 0, -60, 0 )
				// floor.receiveShadow = true
				// scene.add(floor)
				
				// Floor
				const gridHelper = new THREE.GridHelper( 2500, 50 )
				gridHelper.position.set( 0, -60, 0 )
				gridHelper.name = 'floor'
				scene.add( gridHelper )
				
				// Orbit controls
				controls = new OrbitControls( camera, renderer.domElement )
				window.addEventListener( 'resize', onWindowResize )
				controls.rotateSpeed = 0.8
				controls.zoomSpeed = 0.2
				controls.enableDamping = true
				controls.enablePan = true
				controls.dampingFactor = 0.2
				controls.minDistance = 10
				controls.maxDistance = 500
				
				// Transformation controls
				transControl = new TransformControls( camera, renderer.domElement )
				// transControl.addEventListener( 'change', function() { renderer.render( scene, camera ) } )
				// transControl.addEventListener( 'dragging-changed', function ( event ) {
				// 	controls.enabled = ! event.value;
				// } )
				
				const refBox = new THREE.BoxGeometry(10, 10, 10)
				const material = new THREE.MeshNormalMaterial( {side: THREE.DoubleSide, wireframe: false} )
				refBoxMesh = new THREE.Mesh(refBox, material)
			}
			
			function deflateActuators() {
				// parameters for linear actuator
				const foldingVelocity = Math.PI / 2.0

				// parameters for bending actuator
				const hingeGroup1 = []
				const hingeGroup2 = []
				const unitNumber = 6
				const unitHingeNum = 16
				
				for ( let i = 0; i < unitNumber; i++ ) {
					hingeGroup1.push( i*unitHingeNum+1, i*unitHingeNum+2, i*unitHingeNum+3, i*unitHingeNum+5, i*unitHingeNum+6, i*unitHingeNum+7 )
					hingeGroup2.push( i*unitHingeNum+0, i*unitHingeNum+4, i*unitHingeNum+8, i*unitHingeNum+9, i*unitHingeNum+10, i*unitHingeNum+11 )
					if ( i < unitNumber - 1 ) {
						hingeGroup1.push( i*unitHingeNum+12, i*unitHingeNum+13, i*unitHingeNum+14, i*unitHingeNum+15 )
					}
				}

				// Assign different stiffness, relaxation to two groups of hinge constraints
				const stiffness_1 = 1e6
				const relaxation_1 = 0.5
				const stiffness_2 = 1e10
				const relaxation_2 = 0.8
				const timeStep = 1/60
				const initialHingeVelocity_1 = -Math.PI / 0.55
				const initialHingeVelocity_2 = Math.PI / 0.3
				
				// Iterate the array of deflationActuators
				for ( let i = 0; i < deflationActuators.length; i++ ) {
					const index = deflationActuators[i]
					
					// if this is a linear actuator
					if ( tubeInfoList[index].tubeType == 0 ) {
						// Give velocity to hingeConstraints
						tubeInfoList[index].hingeConstraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(foldingVelocity) )
						
						// setTimeout(() => {
						// 	const velocity = 0
						// 	constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
						// }, foldingDuration)
					} 
					
					// if this is a bending actuator
					if ( tubeInfoList[index].tubeType == 1 ) {
						// Give opposite velocity to hingeConstraints for bending behavior
						tubeInfoList[index].hingeConstraints.forEach( (hingeConstraint, index) => {
							if ( hingeGroup1.includes(index) ) {
								hingeConstraint.equations.forEach( function( equation ) {
									equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
								})
								hingeConstraint.enableMotor()
								hingeConstraint.setMotorSpeed( initialHingeVelocity_1 )
							}
							
							if ( hingeGroup2.includes(index) ) {
								hingeConstraint.equations.forEach( function( equation ) {
									equation.setSpookParams( stiffness_2, relaxation_2, timeStep )
								})
								hingeConstraint.enableMotor()
								hingeConstraint.setMotorSpeed( initialHingeVelocity_2 )
							}
						})
					}
				}
			}
			
			function stopFacesFoldThrough() {
				// Stop hinge bodies folding through each other by setting minimum distance while deflation
				for ( let i = 0; i < deflationActuators.length; i++ ) {
					const index = deflationActuators[i]
					
					// if this is a linear actuator
					if ( tubeInfoList[index].tubeType == 0 ) {
						const refBody1 = tubeInfoList[index].hingeBodies[17]
						const refBody2 = tubeInfoList[index].hingeBodies[25]
						
						if ( refBody1.position.distanceSquared( refBody2.position ) < disSquMinLinear ) {
							tubeInfoList[index].hingeBodies.forEach( body => body.sleep() )
						}
					}
					
					// if this is a bending actuator
					if ( tubeInfoList[index].tubeType == 1 ) {
						const refBody1 = tubeInfoList[index].hingeBodies[17]
						const refBody2 = tubeInfoList[index].hingeBodies[25]
						
						if ( refBody1.position.distanceSquared( refBody2.position ) < disSquMinBending ) {
							tubeInfoList[index].hingeBodies.forEach( body => body.sleep() )
						}
					}
				}
			}
			
			function inflateTube() {
				const velocity = unfoldingVelocity
				constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				// setTimeout(() => {
				// 	const velocity = 0
				// 	constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				// }, unFoldingDuration)
			}
			
			function stopInflation( inflationConstraints ) {
				// Prevent the tube from becoming a flat surface while inflation
				if ( bodies[1].position.distanceSquared(bodies[9].position) >= disSquMaxLinear ) {
					const velocity = Math.PI / 1000
					console.log("stopInflation")
					console.log(velocity)
					constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				}
			}
			
			function onWindowResize() {
				const width = window.innerWidth
				const height = window.innerHeight
				camera.aspect = width / height
				camera.updateProjectionMatrix()
				renderer.setSize( width, height )
			}
			
			function render() {
				//hlight 不同的airchannel

				// if (inGroupmode(controlType) && changeFlag==1){
				// 	var a = parseInt(controlType.substr(-1))-1
				// 	changeFlag = 0
				// 	console.log(colors[a])
				// 	tubeInfoList.forEach((object)=>{
				// 		if(object.tubeVisual.name == controlType){							
				// 			object.tubeVisual.children.forEach( (mesh) => {
				// 				mesh.material.emissive.setHex(colors[a]);
				// 				// console.log(object.children)
				// 			})
				// 		}
				// 		else{
				// 			object.tubeVisual.children.forEach( (mesh) => {
				// 				mesh.material.emissive.setHex(initColor );
				// 				// console.log(object.children)
				// 			})
				// 		}
				// 	})
				// }

				//highlight

				const mouse = new THREE.Vector2()
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1
        		mouse.y = -(( event.clientY / window.innerHeight ) * 2 - 1)
				
				// Get the picking ray from the point
				const raycaster = new THREE.Raycaster()
				raycaster.setFromCamera( mouse, camera )
				// console.log(INTERSECTED)
				// 计算物体和射线的焦点
				// const intersects = raycaster.intersectObjects( scene.children );
				let selectedConnectorIndex
				let selectedTubeIndex
				// Loop the data lists to get which object is selected by the user
				for ( let i = 0; i < connectorMeshes.length; i++ ) {
					const intersects = raycaster.intersectObject( connectorMeshes[i] )
					// Get the closest hit object
					if ( intersects.length > 0 ) {
						// const object = hits[0].object
						selectedConnectorIndex = i
					}
				}
				// Get selected tube by the user
				for ( let i = 0; i < tubeInfoList.length; i++ ) {
					const intersects = raycaster.intersectObject( tubeInfoList[i].tubeVisual )
					if ( intersects.length > 0 ) {
						selectedTubeIndex = i
					}
				}
				// console.log(intersects.length)
				// if ( intersects.length > 0 ) {
				// 	if(intersects[ 0 ].object.name=="floor"){
				// 			intersects.splice(0,intersects.length)
				// 		}
				// }

				if ( controlType == 'Add a new actuator' ) {
					// console.log(connectorMeshes[selectedConnectorIndex])
					if(connectorMeshes[selectedConnectorIndex]){
						if ( INTERSECTED != connectorMeshes[selectedConnectorIndex] ) {
							if ( INTERSECTED ) {
								INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
							}
							INTERSECTED = connectorMeshes[selectedConnectorIndex]
							INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
							INTERSECTED.material.emissive.setHex( colors[0] );
						}
						

					}
					else{
						if ( INTERSECTED ){
							INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
						} 
						INTERSECTED = null;
					}
				}
				if ( inGroupmode(controlType) || controlType == 'Remove an actuator' || controlType == 'Rotate the bending direction by 90 degrees') {
					if(changeFlag){
						tubeInfoList.forEach((object)=>{
							if(object.tubeVisual.name == controlType){							
								object.tubeVisual.children.forEach( (mesh) => {
									mesh.material.emissive.setHex(colors[parseInt(controlType.substr(-1))]);
									// console.log(object.children)
								})
							}
							else{
								object.tubeVisual.children.forEach( (mesh) => {
									mesh.material.emissive.setHex(initColor );
									// console.log(object.children)
								})
							}
						})
						changeFlag = 0
					}

					if(tubeInfoList[selectedTubeIndex]){
						if ( INTERSECTED != tubeInfoList[selectedTubeIndex].tubeVisual ) {
						// console.log(intersects[ 0 ].object)
							if ( INTERSECTED ) {
									INTERSECTED.children.forEach( (mesh) => {
										mesh.material.emissive.setHex(INTERSECTED.currentHex);
									})
							}
							INTERSECTED = tubeInfoList[selectedTubeIndex].tubeVisual;
							
							if(INTERSECTED.name == controlType){							
								INTERSECTED.currentHex = colors[parseInt(controlType.substr(-1))]
							}				
							else {
								INTERSECTED.currentHex = INTERSECTED.children[0].material.emissive.getHex();
							}
							INTERSECTED.children.forEach( (mesh) => {
								mesh.material.emissive.setHex(colors[0]);
							})
						}

					} 
					else {
							if ( INTERSECTED ){
								INTERSECTED.children.forEach( (mesh) => {
										mesh.material.emissive.setHex(INTERSECTED.currentHex);
								})
							} 
							INTERSECTED = null;
							changeFlag = 1
					}
				}			
				
				// renderer.render( scene, camera );
			}
			window.addEventListener( 'pointermove', render );
		</script>
	</body>
</html>
