<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Origami Actuators</title>
		<!-- <link rel="stylesheet" href="css/style.css" type="text/css" /> -->
		<style>
			body { margin: 0; }
			.lil-gui {
				--font-size: 16px;
				--input-font-size: 16px;
				--widget-height: 35px;
				--width: 400px;
			}
		</style>
	</head>
	
	<body>
		<!-- <script src="../node_modules/three/build/three.min.js"></script> -->
		<script type="importmap">
			{
				"imports": {
					"three": "../node_modules/three/build/three.module.js",
					"three/addons/": "../node_modules/three/examples/jsm/",
					"cannon-es": "../node_modules/cannon-es/dist/cannon-es.js"
				}
			}
		</script>
		
        <script type="module">
			import * as THREE from 'three'
			import * as CANNON from 'cannon-es'
			import {GUI} from 'three/addons/libs/lil-gui.module.min.js'
			import {OrbitControls} from 'three/addons/controls/OrbitControls.js'
			
			/**
			 * Todo List:
			 * Step1: Reset folding ratio to 0.75 (CZT)
			 * Change tube type
			 * Remove connector
			 * Add actuator one by one
			 * Add basic primitive shape
			 * Step4: Arduino communication
			*/
			
			// Three.js variables for render
			let renderer, camera, scene
			let controls
			
			// Cannon.js variables for physical simulation
			let world
			let useGravity = false
			
			// Set hinge motor velocity that determines speed and direction
			const initialHingeVelocity = 0
			const foldingVelocity = Math.PI / 2.0
			const foldingDuration = 1600
			const unfoldingVelocity = - Math.PI / 4
			const unFoldingDuration = 3000
			const disSquMinLinear = 150
			const disSquMinBending = 150
			const disSquMaxLinear = 720
			
			// Keep in sync the bodies with the visuals, they always have the same length
			let bodies = []
			let visuals = []
			
			// User interaction variables
			let tubeInfoList = []
			let connectorMeshes = []
			let connectorBodies = []
			
			let deflationActuators = []
			let inflationActuators = []
			
			// GUI settings
			const gui = new GUI()
			var controlType = null
			
			const step1obj = {
				'Type of actuator': 'linear actuator',
				'Add a new actuator': function() { controlType = 'Add a new actuator' },
				'Remove an actuator': function() { controlType = 'Remove an actuator' },
				'Rotate the bending direction by 90 degrees': function() { controlType = 'Rotate the bending direction by 90 degrees' },
				'Load mesh': function() { controlType = 'Load mesh' }
			}
			
			const step2obj = {
				'Select actuators to create an air channel': function() {},
				'Finish Selection': function() {},
				'Air channel 1': '1 2 5',
				'Air channel 2': '3 4 6 7'
			}
			
			const step3obj = {
				'Choose an air channel': 'Air channel 1',
				'Actuation method': 'Deflation',
				'Start time (s)': 0.5,
				'End time (s)': 3.0,
				'Add to sequence motion': function() {},
				'Preview motion': false,
				'Add loop control': true
			}
			
			const step4obj = {
				'Generate control code': function() {}
			}
			
			let INTERSECTED = 0
			
			initThree()
			initCannon()
			
			initializeDefaultActuators()
			animate()
			
			initGUI()
			
			function initGUI() {
				/**
				 * User interface & design workflow
				*/
				var step1 = gui.addFolder( 'Step 1: Create a Shape' )
				step1.add( step1obj, 'Type of actuator', ['linear actuator', 'bending actuator'] )
				step1.add( step1obj, 'Add a new actuator' )
				step1.add( step1obj, 'Remove an actuator' )
				step1.add( step1obj, 'Rotate the bending direction by 90 degrees')
				// step1.add( step1obj, 'Load mesh', 'Load mesh' )
				step1.open()
				
				var step2 = gui.addFolder( 'Step 2: Group Actuators' )
				step2.add( step2obj, 'Select actuators to create an air channel' )
				step2.add( step2obj, 'Air channel 1' )
				step2.add( step2obj, 'Air channel 2' )
				step2.add( step2obj, 'Finish Selection')
				step2.open()
				
				// Different channels will be displayed in different colors
				var step3 = gui.addFolder( 'Step 3: Add Actuation & Preview Motion' )
				step3.add( step3obj, 'Choose an air channel', ['Air channel 1', 'Air channel 2'] )
				step3.add( step3obj, 'Actuation method', ['Deflation', 'Inflation'] )
				step3.add( step3obj, 'Start time (s)', 0, 1, 0.1 )
				step3.add( step3obj, 'End time (s)', 1, 5, 0.1 )
				step3.add( step3obj, 'Add to sequence motion' )
				step3.add( step3obj, 'Preview motion' ).onChange( previewMotion )
				step3.add( step3obj, 'Add loop control' )
				step3.open()
				
				var step4 = gui.addFolder( 'Step 4: Assemble & Generate Control Code' )
				step4.add( step4obj, 'Generate control code' )
				step4.open()
			}
			
			// User interactions
			window.addEventListener( 'pointerdown', (event) => {
				/**
				 * Fired when a pointer becomes active state
				 * Cast a ray from where the mouse is pointing to select a connector
				 * Get 3D point from the client x y coordinates
				*/
				const mouse = new THREE.Vector2()
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1
				mouse.y = -(( event.clientY / window.innerHeight ) * 2 - 1)
				
				// Get the picking ray from the point
				const raycaster = new THREE.Raycaster()
				raycaster.setFromCamera( mouse, camera )
				
				let selectedConnectorIndex
				let selectedTubeIndex
				
				// Loop the data lists to get which object is selected by the user
				for ( let i = 0; i < connectorMeshes.length; i++ ) {
					const hits = raycaster.intersectObject( connectorMeshes[i] )
					// Get the closest hit object
					if ( hits.length > 0 ) {
						// const object = hits[0].object
						selectedConnectorIndex = i
					}
				}
				
				// Get selected tube by the user
				for ( let i = 0; i < tubeInfoList.length; i++ ) {
					const hits = raycaster.intersectObject( tubeInfoList[i].tubeVisual )
					if ( hits.length > 0 ) {
						selectedTubeIndex = i
					}
				}
				
				// Divide mouse selections based on the variable controlType
				if ( controlType == 'Add a new actuator' ) {
					addNewActuator( selectedConnectorIndex )
				}
				
				if ( controlType == 'Remove an actuator' ) {
					removeActuator( selectedTubeIndex )
				}
				
				// Clear the last selection
				selectedConnectorIndex = undefined
				selectedTubeIndex = undefined
			})
			
			// User interface functions
			function addNewActuator( selectedConnectorIndex ) {
				if ( step1obj['Type of actuator'] == 'linear actuator' ) {
					var tubeType = 0
				} else if ( step1obj['Type of actuator'] == 'bending actuator' ) {
					var tubeType = 1
				}
				
				if ( selectedConnectorIndex != undefined ) {
					console.log("Add a " + step1obj['Type of actuator'])
					
					var angleIndex = 4
					var tube = addMiuraTube( tubeType, selectedConnectorIndex, angleIndex )
					tubeInfoList.push( tube )
				} else {
					// console.log('No connector is selected for adding new actuator')
				}
			}
			
			function removeActuator( selectedTubeIndex ) {
				if ( selectedTubeIndex != undefined ) {
					// Remove the physical cannon.js body
					world.removeBody( tubeInfoList[ selectedTubeIndex ].hingeBodies )
					world.removeConstraint( tubeInfoList[ selectedTubeIndex ].hingeConstraints )
					
					// Update the index of deflationActuators
					const index = deflationActuators.indexOf( selectedTubeIndex )
					if ( index > -1 ) {
						deflationActuators.splice( index, 1 )
						for ( let i = index; i < deflationActuators.length; i++ ) {
							deflationActuators[index] = deflationActuators[index] - 1
						}
					} else {
						for ( let i = 0; i < deflationActuators.length; i++ ) {
							if ( deflationActuators[i] > selectedTubeIndex ) {
								deflationActuators[i] = deflationActuators[i] - 1
							}
						}
					}
					
					// Remove the three.js object from the scene
					scene.remove( tubeInfoList[ selectedTubeIndex ].tubeVisual )
					
					// Remove the item from the data array
					tubeInfoList.splice( selectedTubeIndex, 1 )
					
					// Remove the end connector simultaneously
					var inuse = false
					for ( let i = 0; i < connectorMeshes.length; i++ ) {
						const aabb = new THREE.Box3()
						aabb.setFromObject( connectorMeshes[i] )
						const center = new THREE.Vector3()
						aabb.getCenter( center )
						
						for ( let j = 0; j < tubeInfoList.length; j++ ) {
							const aabbTube = new THREE.Box3()
							aabbTube.setFromObject( tubeInfoList[j].tubeVisual )
							const centerTube = new THREE.Vector3()
							aabbTube.getCenter( centerTube )
							
							const dis = center.distanceTo( centerTube )
							if ( Math.abs( dis - 93 ) < 1 ) {
								inuse = true
							}
						}
						
						if ( inuse == false ) {
							scene.remove( connectorMeshes[i] )
							console.log( connectorMeshes[i] )
						}
						inuse = false
					}
				}
			}
			
			function previewMotion() {
				// Preview motion based on the user defined actuation sequence
				deflateActuators()
				// inflateTube( inflationLinearActuators )
			}
			
			// Basic functions
			function initializeDefaultActuators() {
				/**
				 * Initialize a default connector in the physical world and visualize it in the scene
				 * Get parameters from the user interface
				 * Let users manipulate tubes in the scene by selecting the connector and pre-defined angles
				*/
				const defaultConnector = initDefaultConnector()
				connectorBodies.push( defaultConnector )
				bodyToMesh( defaultConnector ).forEach( (mesh) => {
					scene.add( mesh )
					connectorMeshes.push( mesh )
				})
				
				var tubeType = 1
				var connectorIndex = 0
				var angleIndex = 0
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeInfoList.push( tube )
				
				var tubeType = 0
				var connectorIndex = 0
				var angleIndex = 1
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeInfoList.push( tube )
				
				var tubeType = 0
				var connectorIndex = 1
				var angleIndex = 2
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeInfoList.push( tube )
				
				var tubeType = 0
				var connectorIndex = 0
				var angleIndex = 4
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeInfoList.push( tube )
				var index = 3
				deflationActuators.push( index )
				
				var tubeType = 1
				var connectorIndex = 1
				var angleIndex = 4
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeInfoList.push( tube )
				var index = 4
				deflationActuators.push( index )
				
				var tubeType = 0
				var connectorIndex = 2
				var angleIndex = 4
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeInfoList.push( tube )

				var tubeType = 0
				var connectorIndex = 3
				var angleIndex = 1
				var tube = addMiuraTube( tubeType, connectorIndex, angleIndex )
				tubeInfoList.push( tube )
				var index = 6
				deflationActuators.push( index )
			}
			
			function addMiuraTube( tubeType, connectorIndex, angleIndex ) {
				/**
				 * Initiate a new physical tube with customized position and quaternion
				 * Treat a new miura-ori tube as a three.js group and render
				 * Automatically add connector bodies to the tube
				 * tubeType is 0 => straight miura-ori tube; tubeType is 1 => bending miura-ori tube
				*/
				
				// Calculate position and quaternion according to the connectorIndex and angleIndex
				const quaternion = new CANNON.Quaternion()
				
				if ( angleIndex == 0 ) {
					// Pre-defined angles
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), 0 )
				} else if ( angleIndex == 1 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), Math.PI/3 )
				} else if ( angleIndex == 2 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), Math.PI/3*2 )
				} else if ( angleIndex == 3 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 1, 0), Math.PI )
				} else if ( angleIndex == 4 ) {
					quaternion.setFromAxisAngle( new CANNON.Vec3(0, 0, 1), Math.PI/2 )
				}
				
				// Copy pivot connector position
				const position = new CANNON.Vec3().copy( connectorBodies[connectorIndex].position )
				
				const intervalDistance = 12.954878  // half width of the Miura-ori tube unit
				const sphereRadius = 15.0  // connector bounding sphere radius
				const unitVec = new CANNON.Vec3( sphereRadius + intervalDistance, 0, 0 )
				quaternion.vmult( unitVec, unitVec )
				position.vadd( unitVec, position )
				
				// Render tube physical bodies to the view based on customized position and quaternion
				if ( tubeType == 0 ) {
					// straight miura-ori tube
					var tubeInfo = initDefaultMiuraTube( position, quaternion )
				} else if ( tubeType == 1 ) {
					// bending miura-ori tube
					var tubeInfo = initBendingMiuraTube( position, quaternion )
				}
				
				const hingeBodies = tubeInfo.hingeBodiesArray
				const hingeConstraints = tubeInfo.constraints
				
				const tubeVisual = new THREE.Group()
				hingeBodies.forEach( (body, i) => {
					const meshes = bodyToMesh( body )
					meshes.forEach( (mesh) => { tubeVisual.add( mesh ) } )
				})
				scene.add( tubeVisual )
				
				// Automatically add new connector body to the scene when adding a new tube
				const newConnector = attachConnector( connectorIndex, hingeBodies, unitVec )
				if ( newConnector != undefined ) {
					connectorBodies.push( newConnector )
					bodyToMesh( newConnector ).forEach( (mesh) => {
						scene.add( mesh )
						connectorMeshes.push( mesh )
					})
				}
				
				return {tubeType, tubeVisual, hingeBodies, hingeConstraints}
			}
			
			function initDefaultConnector() {
				/**
				 * Initialize a default connector in the physical world
				*/
				const sphereRadius = 15
				const sphereShape = new CANNON.Sphere(sphereRadius)
				
				const defaultConnector = new CANNON.Body({
					mass: 0.1,
					type: CANNON.Body.DYNAMIC,
					shape: sphereShape,
					position: new CANNON.Vec3(0, -45, 0)
				})
				
				// No collision needed
				defaultConnector.collisionFilterGroup = 0
				defaultConnector.collisionFilterMask = 0
				world.addBody(defaultConnector)
				
				return defaultConnector
			}
			
			function attachConnector( connectorIndex, hingeBodies, unitVec ) {
				/**
				 * Add lock constraints between the selected connector and hinge bodies
				 * Attach a new connector to the end of the tube
				*/
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[0] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[2] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[4] ))
				world.addConstraint(new CANNON.LockConstraint( connectorBodies[connectorIndex], hingeBodies[6] ))
				
				// Pre-defined tube bounding box dimensions: length => 155.458538, width => 37.288780, height => 17.527490
				const bBoxLength = 155.458538
				const bBoxWidth = 37.288780
				const bBoxHeight = 17.527490
				
				const sphereRadius = 15
				const sphereShape = new CANNON.Sphere(sphereRadius)
				// const boxShape = new CANNON.Box(new CANNON.Vec3(10,10,10))
				
				const newPos = unitVec.unit()
				const distance = bBoxLength + sphereRadius * 2
				newPos.scale( distance, newPos )
				newPos.vadd( connectorBodies[connectorIndex].position, newPos )
				
				// Set a flag: True => Add a new connector; Flase => Do not add
				let flag = true
				
				// Check if there is a existing connector in the new position
				for ( let i = 0; i < connectorBodies.length; i++ ) {
					const vecEqual = newPos.almostEquals( connectorBodies[i].position )
					if ( vecEqual == true ) {
						flag = false
						
						// Add lock constraints between the exsiting connector and hinge bodies
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-1] ))
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-3] ))
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-5] ))
						world.addConstraint(new CANNON.LockConstraint( connectorBodies[i], hingeBodies[hingeBodies.length-7] ))
					}
				}
				
				if ( flag == false ) {
					return undefined
				} else {
					// Attach a new connector to the end of the tube
					const newConnector = new CANNON.Body({
						mass: 0.1,
						type: CANNON.Body.DYNAMIC,
						shape: sphereShape,
						position: newPos
					})
					newConnector.collisionFilterGroup = 0
					newConnector.collisionFilterMask = 0
					world.addBody(newConnector)
					
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-1] ))
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-3] ))
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-5] ))
					world.addConstraint(new CANNON.LockConstraint( newConnector, hingeBodies[hingeBodies.length-7] ))
					
					return newConnector
				}
			}
			
			function initDefaultMiuraTube( position, quaternion ) {
				/**
				 * Store face coordinates from the Grasshopper file with 0.65 folding ratio
				 * Store vertices and indices for the body and geometry of the miura-ori tube
				 * Initiate the physical miura-ori tube with Trimesh shape
				 * Specify hinge constraints with axis and pivot point
				*/				
				const faceVertices_1 = new Float32Array([
					0, 0, 0,
					0, 12.173610, 8.763745,
					-12.95488, -0.768048, 8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_2 = new Float32Array([
					0, 0, 0,
					12.95488, -12.941658, 0,
					12.954878, -0.768048, 8.763745,
					0, 12.173610, 8.763745
				])
				const faceVertices_3 = new Float32Array([
					0, 12.173610, 8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, 8.763745
				])
				const faceVertices_4 = new Float32Array([
					0, 12.173610, 8.763745,
					12.954878, -0.768048, 8.763745,
					12.954878, 11.405561, 0,
					0, 24.347219, 0
				])
				const faceVertices_5 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					-12.954878, -0.768048, -8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_6 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					12.954878, -0.768048, -8.763745,
					12.954878, -12.941658, 0
				])
				const faceVertices_7 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, -8.763745
				])
				const faceVertices_8 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					12.954878, 11.405561, 0,
					12.954878, -0.768048, -8.763745
				])
				
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				// Number of faces in a miura-ori unit
				const unitNumber = 6	// a miura-ori tube has 6 units
				const unitFacesNum = 8  // a unit has 8 quadrilaterals
				let hingeBodiesArray = new Array( unitNumber * unitFacesNum )
				const mass = 0.1
				
				// Set the quaternion of the intervalVec
				const intervalDistance = 12.954878 * 2
				const intervalVec = new CANNON.Vec3( intervalDistance, 0, 0 )
				const intervalQuat = new CANNON.Quaternion().copy( quaternion )	// Rotate the intervalVec
				intervalQuat.vmult( intervalVec, intervalVec )
				
				// Whether to add hinge constraints (for test)
				const useHingeConstraints = true
				let constraints = []
				
				// Initiatize hinge bodies with shape, position, and quaternion
				for ( let i = 0; i < unitNumber; i++ ) {
                    hingeBodiesArray[ i*unitFacesNum ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum ] )
                    
					hingeBodiesArray[ i*unitFacesNum+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+1 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+2 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+3 ] )

					hingeBodiesArray[ i*unitFacesNum+4 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_5, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+4 ] )
					
					hingeBodiesArray[ i*unitFacesNum+5 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_6, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+5 ] )

					hingeBodiesArray[ i*unitFacesNum+6 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_7, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+6 ] )
					
					hingeBodiesArray[ i*unitFacesNum+7 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_8, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+7 ] )
                }
				
				// Specify a list of hinge constraints
				if (useHingeConstraints) {
					for ( let i = 0; i < unitNumber; i++ ) {
						const axis1 = new CANNON.Vec3( 0, 0.811574, 0.58425 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+1 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis1,	
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis1,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis2 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+2 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis2,
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis2,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis3 = new CANNON.Vec3( 0.707468, -0.706746, 0 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis3,
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis3,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis4 = new CANNON.Vec3( 0, -0.811574, 0.58425 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis4,	
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis4,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis5 = new CANNON.Vec3( 0, -0.811574, 0.58425 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis5,	
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis5,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis6 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis6,
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis6,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis7 = new CANNON.Vec3( -0.707468, 0.706746, 0 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis7,
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis7,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis8 = new CANNON.Vec3( 0, 0.811574, 0.58425 )	// mountain hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+6 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisA: axis8,	
								pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
								axisB: axis8,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis9 = new CANNON.Vec3( 0.707468, 0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+4 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis9,
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis9,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis10 = new CANNON.Vec3( 0.707468, -0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
								pivotA: new CANNON.Vec3( 0, 0, 0 ),
								axisA: axis10,
								pivotB: new CANNON.Vec3( 0, 0, 0 ),
								axisB: axis10,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis11 = new CANNON.Vec3( -0.707468, -0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisA: axis11,
								pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisB: axis11,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						const axis12 = new CANNON.Vec3( -0.707468, 0.706746, 0 ) // vally hinge
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
								pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisA: axis12,
								pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
								axisB: axis12,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						// Specify hinge constraints to connect multiple units
						if ( i < unitNumber -1 ) {
							const axis13 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // mountain hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ (i+1)*unitFacesNum ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
									axisA: axis13,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
									axisB: axis13,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis14 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // vally hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ (i+1)*unitFacesNum+2 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
									axisA: axis14,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
									axisB: axis14,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis15 = new CANNON.Vec3( 0, 0.811574, -0.58425 )  // mountain hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ (i+1)*unitFacesNum+4 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
									axisA: axis15,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
									axisB: axis15,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
							
							const axis16 = new CANNON.Vec3( 0, -0.811574, -0.58425 )  // vally hinge
							constraints.push(
								new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+7], hingeBodiesArray[ (i+1)*unitFacesNum+6 ], {
									pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
									axisA: axis16,
									pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
									axisB: axis16,
									collideConnected: true,
									maxForce: Math.pow(10, 6)
								})
							)
						}
					}
				}

				const stiffness = 1e10
				const relaxation = 0.5
				const timeStep = 1/60
				
				// Add the constraints to the world and enable hinge motor, each tube has 92 hinge constraints
				constraints.forEach( function( constraint ) {
					constraint.equations.forEach(function( equation ) {
						// set greater stiffness on the hinge
						equation.setSpookParams( stiffness, relaxation, timeStep )
					})
					
					constraint.enableMotor()
					constraint.setMotorSpeed( initialHingeVelocity )
					world.addConstraint( constraint )
				})
				
				return {hingeBodiesArray, constraints}
			}
			
			function initBendingMiuraTube( position, quaternion ) {
				// Initiate a physical miura-ori tube with bending simulation
				const faceVertices_1 = new Float32Array([
					0, 0, 0,
					0, 12.173610, 8.763745,
					-12.95488, -0.768048, 8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_2 = new Float32Array([
					0, 0, 0,
					12.95488, -12.941658, 0,
					12.954878, -0.768048, 8.763745,
					0, 12.173610, 8.763745
				])
				const faceVertices_3 = new Float32Array([
					0, 12.173610, 8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, 8.763745
				])
				const faceVertices_4 = new Float32Array([
					0, 12.173610, 8.763745,
					12.954878, -0.768048, 8.763745,
					12.954878, 11.405561, 0,
					0, 24.347219, 0
				])
				const faceVertices_5 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					-12.954878, -0.768048, -8.763745,
					-12.954878, -12.941658, 0
				])
				const faceVertices_6 = new Float32Array([
					0, 0, 0,
					0, 12.173610, -8.763745,
					12.954878, -0.768048, -8.763745,
					12.954878, -12.941658, 0
				])
				const faceVertices_7 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					-12.954878, 11.405561, 0,
					-12.954878, -0.768048, -8.763745
				])
				const faceVertices_8 = new Float32Array([
					0, 12.173610, -8.763745,
					0, 24.347219, 0,
					12.954878, 11.405561, 0,
					12.954878, -0.768048, -8.763745
				])
				
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				// Number of faces in a miura-ori unit
				const unitNumber = 6	// a miura-ori tube has 6 units
				const unitFacesNum = 8  // a unit has 8 quadrilaterals
				let hingeBodiesArray = new Array( unitNumber * unitFacesNum )
				const mass = 0.1
				
				// Set the quaternion of the intervalVec
				const intervalDistance = 12.954878 * 2
				const intervalVec = new CANNON.Vec3( intervalDistance, 0, 0 )
				const intervalQuat = new CANNON.Quaternion().copy( quaternion )	// Rotate the intervalVec
				intervalQuat.vmult( intervalVec, intervalVec )
				
				// Whether to add hinge constraints (for test)
				const useHingeConstraints = true
				let constraints = []
				
				// Initiatize hinge bodies with shape, position, and quaternion
				for ( let i = 0; i < unitNumber; i++ ) {
                    hingeBodiesArray[ i*unitFacesNum ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum ] )
                    
					hingeBodiesArray[ i*unitFacesNum+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+1 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+2 ] )
                    
					hingeBodiesArray[ i*unitFacesNum+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
				    })
                    world.addBody( hingeBodiesArray[ i*unitFacesNum+3 ] )

					hingeBodiesArray[ i*unitFacesNum+4 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_5, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+4 ] )
					
					hingeBodiesArray[ i*unitFacesNum+5 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_6, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+5 ] )

					hingeBodiesArray[ i*unitFacesNum+6 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_7, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+6 ] )
					
					hingeBodiesArray[ i*unitFacesNum+7 ] = new CANNON.Body({
						mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_8, indices ),
						position: intervalVec.scale(i).vadd( position ),
						quaternion: intervalQuat
					})
					world.addBody( hingeBodiesArray[ i*unitFacesNum+7 ] )
                }
				
				// Specify a list of hinge constraints
				if (useHingeConstraints) {
					for ( let i = 0; i < unitNumber; i++ ) {
						const axis1 = new CANNON.Vec3( 0, 0.811574, 0.58425 )
						const hinge1 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+1 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis1,	
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis1,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge1 )
						constraints.push( hinge1 )
						
						const axis2 = new CANNON.Vec3( 0.707468, 0.706746, 0 )
						const hinge2 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+2 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisA: axis2,
							pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisB: axis2,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge2 )
						constraints.push( hinge2 )
						
						const axis3 = new CANNON.Vec3( 0.707468, -0.706746, 0 )
						const hinge3 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisA: axis3,
							pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
							axisB: axis3,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge3 )
						constraints.push( hinge3 )
						
						const axis4 = new CANNON.Vec3( 0, -0.811574, 0.58425 )
						const hinge4 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+3 ], {
								pivotA: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisA: axis4,	
								pivotB: new CANNON.Vec3( 0, 12.173610, 8.763745 ),
								axisB: axis4,	
								collideConnected: true,
								maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge4 )
						constraints.push( hinge4 )
						
						const axis5 = new CANNON.Vec3( 0, -0.811574, 0.58425 )
						const hinge5 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis5,	
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis5,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge5 )
						constraints.push( hinge5 )
						
						const axis6 = new CANNON.Vec3( -0.707468, -0.706746, 0 )
						const hinge6 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+4 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisA: axis6,
							pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisB: axis6,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge6 )
						constraints.push( hinge6 )
						
						const axis7 = new CANNON.Vec3( -0.707468, 0.706746, 0 )
						const hinge7 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisA: axis7,
							pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisB: axis7,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge7 )
						constraints.push( hinge7 )
						
						const axis8 = new CANNON.Vec3( 0, 0.811574, 0.58425 )
						const hinge8 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+6 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
							pivotA: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisA: axis8,	
							pivotB: new CANNON.Vec3( 0, 12.173610, -8.763745 ),
							axisB: axis8,	
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge8 )
						constraints.push( hinge8 )
						
						const axis9 = new CANNON.Vec3( 0.707468, 0.706746, 0 )
						const hinge9 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum ], hingeBodiesArray[ i*unitFacesNum+4 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis9,
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis9,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge9 )
						constraints.push( hinge9 )
						
						const axis10 = new CANNON.Vec3( 0.707468, -0.706746, 0 )
						const hinge10 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ i*unitFacesNum+5 ], {
							pivotA: new CANNON.Vec3( 0, 0, 0 ),
							axisA: axis10,
							pivotB: new CANNON.Vec3( 0, 0, 0 ),
							axisB: axis10,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge10 )
						constraints.push( hinge10 )
						
						const axis11 = new CANNON.Vec3( -0.707468, -0.706746, 0 )
						const hinge11 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+2 ], hingeBodiesArray[ i*unitFacesNum+6 ], {
							pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisA: axis11,
							pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisB: axis11,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge11 )
						constraints.push( hinge11 )
						
						const axis12 = new CANNON.Vec3( -0.707468, 0.706746, 0 )
						const hinge12 =	new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ i*unitFacesNum+7 ], {
							pivotA: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisA: axis12,
							pivotB: new CANNON.Vec3( 0, 24.347219, 0 ),
							axisB: axis12,
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
						world.addConstraint( hinge12 )
						constraints.push( hinge12 )
						
						// Specify hinge constraints to connect multiple units
						if ( i < unitNumber - 1 ) {
							const axis13 = new CANNON.Vec3( 0, -0.811574, -0.58425 )
							const hinge13 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+1 ], hingeBodiesArray[ (i+1)*unitFacesNum ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
								axisA: axis13,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
								axisB: axis13,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							world.addConstraint( hinge13 )
							constraints.push( hinge13 )
							
							const axis14 = new CANNON.Vec3( 0, 0.811574, -0.58425 )
							const hinge14 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+3 ], hingeBodiesArray[ (i+1)*unitFacesNum+2 ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, 8.763745 ),
								axisA: axis14,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, 8.763745 ),
								axisB: axis14,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							world.addConstraint( hinge14 )
							constraints.push( hinge14 )
							
							const axis15 = new CANNON.Vec3( 0, 0.811574, -0.58425 )
							const hinge15 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+5 ], hingeBodiesArray[ (i+1)*unitFacesNum+4 ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
								axisA: axis15,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
								axisB: axis15,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							world.addConstraint( hinge15 )
							constraints.push( hinge15 )
							
							const axis16 = new CANNON.Vec3( 0, -0.811574, -0.58425 )
							const hinge16 = new CANNON.HingeConstraint(hingeBodiesArray[ i*unitFacesNum+7], hingeBodiesArray[ (i+1)*unitFacesNum+6 ], {
								pivotA: new CANNON.Vec3( 12.954878, -0.768048, -8.763745 ),
								axisA: axis16,
								pivotB: new CANNON.Vec3( -12.954878, -0.768048, -8.763745 ),
								axisB: axis16,
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
							world.addConstraint( hinge16 )
							constraints.push( hinge16 )
						}
					}
				}
				return {hingeBodiesArray, constraints}
			}
			
			function initFlatMiuraTube() {
				/**
				 * Note that this function folds the tube from a flat surface
				 * Store vertices and indices for the geometry of miura-ori tube
				 * Initiate the physical miura-ori tube with Trimesh shape
				 * Specify hinge constraints with axis and pivot point
				*/
				const faceVertices_1 = new Float32Array([
					0, -15, 0,
					0, 0, 0, 
					-15.0, -10.503123, 0,
					-15.0, -25.503113, 0
				])
				const faceVertices_2 = new Float32Array([
					0, -15, 0,	
					15.0, -25.503113, 0,
					15.0, -10.503123, 0,
					0, 0, 0
				])
				const faceVertices_3 = new Float32Array([
					0, 0, 0,
					0, 15.0, 0,
					-15.0, 4.496877, 0,
					-15.0, -10.503123, 0
				])
				const faceVertices_4 = new Float32Array([
					0, 0, 0,
					15.0, -10.503123, 0,
					15.0, 4.496877, 0,
					0, 15.0, 0
				])
				const indices = new Uint16Array([0,1,2,0,2,3])
				
				const mass = 10
				const intervalDistance = 15.0 * 2
				
				// Define hinge bodies
				for (let i = 0; i < unitNumber; i++) {
                    hingeBodiesArray[ i*4 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_1, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4 ] )
                    
					hingeBodiesArray[ i*4+1 ] = new CANNON.Body({
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_2, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+1 ] )
                    
					hingeBodiesArray[ i*4+2 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_3, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+2 ] )
                    
					hingeBodiesArray[ i*4+3 ] = new CANNON.Body({  
                        mass: mass,
                        type: CANNON.Body.DYNAMIC,
                        shape: new CANNON.Trimesh( faceVertices_4, indices ),
                        position: new CANNON.Vec3( intervalDistance * i, 0, 0 )
				    })
                    world.addBody( hingeBodiesArray[ i*4+3 ] )
                }
				
				// Specify a list of constraints
				for (let i = 0; i < unitNumber; i++) {
					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4 ], hingeBodiesArray[ i*4+1 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0, 1, 0), // vally hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0, 1, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4 ], hingeBodiesArray[ i*4+2 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0.819252, 0.573576, 0), // mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0.819252, 0.573576, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4+1 ], hingeBodiesArray[ i*4+3 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0.819252, -0.573576, 0),	// mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0.819252, -0.573576, 0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)

					constraints.push(
						new CANNON.HingeConstraint(hingeBodiesArray[ i*4+2 ], hingeBodiesArray[ i*4+3 ], {
							pivotA: new CANNON.Vec3(0, 0, 0),
							axisA: new CANNON.Vec3(0,-1,0),	// mountain hinge
							pivotB: new CANNON.Vec3(0, 0, 0),
							axisB: new CANNON.Vec3(0,-1,0),
							collideConnected: true,
							maxForce: Math.pow(10, 6)
						})
					)
					
					if ( i < unitNumber -1 ) {
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*4+1 ], hingeBodiesArray[ (i+1)*4 ], {
								pivotA: new CANNON.Vec3(15, 0, 0),
								axisA: new CANNON.Vec3(0, -1, 0), // mountain hinge
								pivotB: new CANNON.Vec3(-15, 0, 0),
								axisB: new CANNON.Vec3(0, -1, 0),
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
						
						constraints.push(
							new CANNON.HingeConstraint(hingeBodiesArray[ i*4+3 ], hingeBodiesArray[ (i+1)*4+2 ], {
								pivotA: new CANNON.Vec3(15, 0, 0),
								axisA: new CANNON.Vec3(0, 1, 0), // vally hinge 
								pivotB: new CANNON.Vec3(-15, 0, 0),
								axisB: new CANNON.Vec3(0, 1, 0),
								collideConnected: true,
								maxForce: Math.pow(10, 6)
							})
						)
					}
				}
				
				const stiffness = 1e10
				const relaxation = 4
				const timeStep = 1/60
				// add the constraints to the world and enable hinge motor
				constraints.forEach( function( constraint ) {
					constraint.equations.forEach(function( equation ) {
						// set greater stiffness on the hinge
						equation.setSpookParams( stiffness, relaxation, timeStep )
					})
					
					constraint.enableMotor()
					constraint.setMotorSpeed( initialHingeVelocity )
					world.addConstraint( constraint )
				})
			}
			
			function initCannon() {
				world = new CANNON.World()
				world.solver.iterations = 20
				world.quatNormalizeFast = true
				
				// Set the gravity vector
				if (useGravity == true) {
					world.gravity.set(0, -9.82, 0)
				}
				
				// Create a static ground
				const groundBody = new CANNON.Body({
					type: CANNON.Body.Static,
					shape: new CANNON.Plane(),
					material: new CANNON.Material('ground')
				})
				
				// Visualization of the plane geometry is defined in initThree()
				groundBody.quaternion.setFromEuler( -Math.PI / 2, 0, 0 )
				groundBody.position.set( 0, -60, 0 )
				world.addBody(groundBody)
			}
			
			function bodyToMesh( body ) {
				/**
				 * Convert cannon bodies to three.js meshes directly
				*/
				if ( !(body instanceof CANNON.Body) ) {
					throw new Error('The argument passed to bodyToMesh() is not a body')
				}

				// Materials
				const basicMaterial = new THREE.MeshBasicMaterial( {color: 0x44aa88, side: THREE.DoubleSide, wireframe: false} )
				const phongMaterial = new THREE.MeshPhongMaterial( {color: 0x44aa88, side: THREE.DoubleSide, wireframe: false} )
				const normalMaterial = new THREE.MeshNormalMaterial( {side: THREE.DoubleSide, wireframe: false} )
				const material = normalMaterial
				// const colors = new Float32Array()
				
				// Get the mesh of body
				const meshes = body.shapes.map( (shape) => {
					switch (shape.type) {
						// check the shape type
						case CANNON.Shape.types.TRIMESH: {
							const verticeNum = shape.indices.length * 3
							const v0 = new CANNON.Vec3()
							const v1 = new CANNON.Vec3()
							const v2 = new CANNON.Vec3()
							
							const geometry = new THREE.BufferGeometry()
							const vertices = new Float32Array( verticeNum )
							const indices = new Uint16Array( shape.indices.length )
							let posNdx = 0
							
							for ( let i = 0; i < shape.indices.length / 3; i++ ) {
								shape.getTriangleVertices( i, v0, v1, v2 )
								
								const positions = [v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z]
								posNdx = posNdx + i * 3 * 3
								vertices.set( positions, posNdx )
								indices.set( [i*3, i*3+1, i*3+2], i * 3 )
							}
							// console.log(vertices)
							// console.log(indices)
							geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3) )
							geometry.setIndex( new THREE.BufferAttribute(indices, 1) )
							
							geometry.computeBoundingSphere()
							geometry.computeVertexNormals()
							
							return new THREE.Mesh( geometry, material )
						}
						
						case CANNON.Shape.types.SPHERE: {
							const geometry = new THREE.SphereGeometry( shape.radius )
							return new THREE.Mesh( geometry, material )
						}
						
						case CANNON.Shape.types.BOX: {
							const geometry = new THREE.BoxGeometry( shape.halfExtents.x * 2, shape.halfExtents.y * 2, shape.halfExtents.z * 2 )
							return new THREE.Mesh( geometry, material )
						}
					}
				})
				
				// In case multiple shapes in one body (compound body)
				meshes.forEach( (mesh, i) => {
					// console.log(mesh)
					mesh.position.copy( body.shapeOffsets[i] )
					mesh.quaternion.copy( body.shapeOrientations[i] )
					// Enable shadows on every object
					mesh.receiveShadow = true
    				mesh.castShadow = true
					
					// For function animation()
					bodies.push(body)
					visuals.push(mesh)
				})
				return meshes
			}
			
			function initThree() {
				THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 )
				
				// Renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } )
				renderer.setPixelRatio( window.devicePixelRatio )
				renderer.setSize( window.innerWidth, window.innerHeight )
				renderer.outputEncoding = THREE.sRGBEncoding
				document.body.appendChild( renderer.domElement )
				renderer.shadowMap.enabled = true
    			renderer.shadowMap.type = THREE.PCFSoftShadowMap
				
				renderer.shadowMap.enabled = true
        		renderer.shadowMap.type = THREE.PCFSoftShadowMap
				
				// Camera
				camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 0.1, 1000 )
				camera.position.set( 0, 500, 400 )

				// Scene
				scene = new THREE.Scene()
				scene.background = new THREE.Color( 'rgb(240, 240, 240)' )
				
				// Lights
				scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.1 ) )
				const directionalLight = new THREE.DirectionalLight( 0xFFFFFF, 2 )
				directionalLight.position.set( -30, 40, 30 )
				directionalLight.target.position.set( 0, 0, 0 )
				scene.add( directionalLight )
				
				// const floorGeometry = new THREE.PlaneGeometry( 5000, 5000, 100, 100 )
				// floorGeometry.rotateX( -Math.PI / 2 )
				// const floorMaterial = new THREE.MeshLambertMaterial( { color: 0x787878 } )
				// const floor = new THREE.Mesh( floorGeometry, floorMaterial )
				// floor.position.set( 0, -60, 0 )
				// floor.receiveShadow = true
				// scene.add(floor)
				
				// Floor
				const gridHelper = new THREE.GridHelper( 2500, 50 )
				gridHelper.position.set( 0, -60, 0 )
				scene.add( gridHelper )
				
				// Orbit controls
				controls = new OrbitControls( camera, renderer.domElement )
				window.addEventListener( 'resize', onWindowResize )
				controls.rotateSpeed = 0.8
				controls.zoomSpeed = 0.2
				controls.enableDamping = true
				controls.enablePan = true
				controls.dampingFactor = 0.2
				controls.minDistance = 10
				controls.maxDistance = 500
			}
			
			function animate() {
				requestAnimationFrame( animate )
				
				// Step the physical simulation forward
				world.fixedStep()
				
				// update the position and orientation of the mesh to match the CannonBody
				// for ( let i = 0; i < bodies.length; i++ ) {
				// 	const body = bodies[i]
				// 	const visual = visuals[i]
				// 	visual.position.copy( bodies[i].position )
        		// 	visual.quaternion.copy( bodies[i].quaternion )
				// }
				for ( let i = 0; i < tubeInfoList.length; i++ ) {
					for ( let j = 0; j < tubeInfoList[i].hingeBodies.length; j++ ) {
						const body = tubeInfoList[i].hingeBodies[j]
						const visual = tubeInfoList[i].tubeVisual.children[j]
						visual.position.copy( body.position )
						visual.quaternion.copy( body.quaternion )
					}
				}
				
				for ( let i = 0; i < connectorBodies.length; i++ ) {
					const body = connectorBodies[i]
					const visual = connectorMeshes[i]
					visual.position.copy( body.position )
					visual.quaternion.copy( body.quaternion )
				}
				
				// Stop hinge bodies folding through each other while deflation
				stopFacesFoldThrough()
				
				// Prevent the tube from becoming a flat surface while inflation
				// stopInflation()
				
				// Render three.js objects
				controls.update()
				renderer.render( scene, camera )
			}
			
			function deflateActuators() {
				// parameters for linear actuator
				const foldingVelocity = Math.PI / 2.0

				// parameters for bending actuator
				const hingeGroup1 = []
				const hingeGroup2 = []
				const unitNumber = 6
				const unitHingeNum = 16
				
				for ( let i = 0; i < unitNumber; i++ ) {
					hingeGroup1.push( i*unitHingeNum+1, i*unitHingeNum+2, i*unitHingeNum+3, i*unitHingeNum+5, i*unitHingeNum+6, i*unitHingeNum+7 )
					hingeGroup2.push( i*unitHingeNum+0, i*unitHingeNum+4, i*unitHingeNum+8, i*unitHingeNum+9, i*unitHingeNum+10, i*unitHingeNum+11 )
					if ( i < unitNumber - 1 ) {
						hingeGroup1.push( i*unitHingeNum+12, i*unitHingeNum+13, i*unitHingeNum+14, i*unitHingeNum+15 )
					}
				}

				// Assign different stiffness, relaxation to two groups of hinge constraints
				const stiffness_1 = 1e6
				const relaxation_1 = 0.5
				const stiffness_2 = 1e10
				const relaxation_2 = 0.8
				const timeStep = 1/60
				const initialHingeVelocity_1 = -Math.PI / 0.55
				const initialHingeVelocity_2 = Math.PI / 0.3
				
				// Iterate the array of deflationActuators
				for ( let i = 0; i < deflationActuators.length; i++ ) {
					const index = deflationActuators[i]
					
					// if this is a linear actuator
					if ( tubeInfoList[index].tubeType == 0 ) {
						// Give velocity to hingeConstraints
						tubeInfoList[index].hingeConstraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(foldingVelocity) )
						
						// setTimeout(() => {
						// 	const velocity = 0
						// 	constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
						// }, foldingDuration)
					} 
					
					// if this is a bending actuator
					if ( tubeInfoList[index].tubeType == 1 ) {
						// Give opposite velocity to hingeConstraints for bending behavior
						tubeInfoList[index].hingeConstraints.forEach( (hingeConstraint, index) => {
							if ( hingeGroup1.includes(index) ) {
								hingeConstraint.equations.forEach( function( equation ) {
									equation.setSpookParams( stiffness_1, relaxation_1, timeStep )
								})
								hingeConstraint.enableMotor()
								hingeConstraint.setMotorSpeed( initialHingeVelocity_1 )
							}
							
							if ( hingeGroup2.includes(index) ) {
								hingeConstraint.equations.forEach( function( equation ) {
									equation.setSpookParams( stiffness_2, relaxation_2, timeStep )
								})
								hingeConstraint.enableMotor()
								hingeConstraint.setMotorSpeed( initialHingeVelocity_2 )
							}
						})
					}
				}
			}
			
			function stopFacesFoldThrough() {
				// Stop hinge bodies folding through each other by setting minimum distance while deflation
				for ( let i = 0; i < deflationActuators.length; i++ ) {
					const index = deflationActuators[i]
					
					// if this is a linear actuator
					if ( tubeInfoList[index].tubeType == 0 ) {
						const refBody1 = tubeInfoList[index].hingeBodies[17]
						const refBody2 = tubeInfoList[index].hingeBodies[25]
						
						if ( refBody1.position.distanceSquared( refBody2.position ) < disSquMinLinear ) {
							tubeInfoList[index].hingeBodies.forEach( body => body.sleep() )
						}
					}
					
					// if this is a bending actuator
					if ( tubeInfoList[index].tubeType == 1 ) {
						const refBody1 = tubeInfoList[index].hingeBodies[17]
						const refBody2 = tubeInfoList[index].hingeBodies[25]
						
						if ( refBody1.position.distanceSquared( refBody2.position ) < disSquMinBending ) {
							tubeInfoList[index].hingeBodies.forEach( body => body.sleep() )
						}
					}
				}
			}
			
			function inflateTube() {
				const velocity = unfoldingVelocity
				constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				
				// setTimeout(() => {
				// 	const velocity = 0
				// 	constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				// }, unFoldingDuration)
			}
			
			function stopInflation( inflationConstraints ) {
				// Prevent the tube from becoming a flat surface while inflation
				if ( bodies[1].position.distanceSquared(bodies[9].position) >= disSquMaxLinear ) {
					const velocity = Math.PI / 1000
					console.log("stopInflation")
					console.log(velocity)
					constraints.forEach( hingeConstraint => hingeConstraint.setMotorSpeed(velocity) )
				}
			}
			
			function onWindowResize() {
				const width = window.innerWidth
				const height = window.innerHeight
				camera.aspect = width / height
				camera.updateProjectionMatrix()
				renderer.setSize( width, height )
			}
			
			// function render() {
			// 	const mouse = new THREE.Vector2()
			// 	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1
        	// 	mouse.y = -(( event.clientY / window.innerHeight ) * 2 - 1)
				
			// 	// Get the picking ray from the point
			// 	const raycaster = new THREE.Raycaster()
			// 	raycaster.setFromCamera( mouse, camera )
			// 	// console.log(INTERSECTED)

			// 	// 
			// 	const intersects = raycaster.intersectObjects( scene.children );
			// 	// console.log(intersects.length)
			// 	if ( intersects.length > 0 ) {
			// 		if(intersects[ 0 ].object.geometry.name=="floor"){
			// 				intersects.pop()
			// 			}
			// 	}
			// 	if ( intersects.length > 0 ) {
			// 		if ( INTERSECTED != intersects[ 0 ].object ) {
			// 			// console.log(intersects[ 0 ].object)

			// 			if ( INTERSECTED ) {
			// 					if (INTERSECTED.parent.type =="Group"){
			// 						INTERSECTED.parent.children.forEach( (mesh) => {
			// 							mesh.material.emissive.setHex(INTERSECTED.currentHex );
			// 					})
			// 					}
			// 					else{
			// 						INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
			// 					}
								
			// 				}

			// 				INTERSECTED = intersects[ 0 ].object;
			// 				INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
			// 				if (INTERSECTED.parent.type =="Group"){
			// 					// console.log(INTERSECTED.parent.type)
			// 					INTERSECTED.parent.children.forEach( (mesh) => {
			// 						mesh.material.emissive.setHex( 0xff0000 );
			// 					})
			// 				}
			// 				else {
			// 					INTERSECTED.material.emissive.setHex( 0xff0000 );
			// 				}

			// 		}

			// 		} else {

			// 			if ( INTERSECTED ){
							
			// 				if (INTERSECTED.parent.type =="Group"){
									
			// 						INTERSECTED.parent.children.forEach( (mesh) => {
			// 							mesh.material.emissive.setHex(INTERSECTED.currentHex );
			// 						})
			// 				}
			// 				else{
			// 					INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
			// 				}
						
			// 			} 

			// 			INTERSECTED = null;

			// 	}			

			// 	// renderer.render( scene, camera );
			// }
			
			// window.addEventListener( 'pointermove', render )
		</script>
	</body>
</html>